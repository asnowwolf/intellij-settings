<application>
  <component name="AppStorage">
    <histories>
      <item value="Dive deeper into the capabilities and advanced feature of the Angular DI system in the following pages:" />
      <item value="`@Inject()` and `@Optional()` are _parameter decorators_. They alter the way the DI framework provides a dependency, by annotating the dependency parameter on the constructor of the class that requires the dependency." />
      <item value="When a component or service declares a dependency, the class constructor takes that dependency as a parameter. You can tell Angular that the dependency is optional by annotating the constructor parameter with `@Optional()`." />
      <item value="`HeroService` *requires* a logger, but what if it could get by without one?" />
      <item value="The behavior is similar when you write a constructor that requires an injected class-based dependency.&#10;When you define a constructor parameter with the `HeroService` class type, Angular knows to inject the service associated with that `HeroService` class token:" />
      <item value="In simple examples, the dependency value is an *instance*, and&#10;the class *type* serves as its own lookup key.&#10;Here you get a `HeroService` directly from the injector by supplying the `HeroService` type as the token:" />
      <item value="The decorator requirement is imposed by TypeScript. TypeScript normally discards parameter type information when it [transpiles](guide/glossary#transpile) the code to JavaScript. TypeScript preserves this information if the class has a decorator and the `emitDecoratorMetadata` compiler option is set `true` in TypeScript's `tsconfig.json` configuration file. The CLI configures `tsconfig.json` with `emitDecoratorMetadata: true`." />
      <item value="When Angular creates a class whose constructor has parameters, it looks for type and injection metadata about those parameters so that it can inject the correct service.&#10;If Angular can't find that parameter information, it throws an error. Angular can only find the parameter information _if the class has a decorator of some kind_.&#10;The `@Injectable()` decorator is the standard decorator for service classes." />
      <item value="Notice that the `Logger` service also has the `@Injectable()` decorator, even though it might not need its own dependencies. In fact, the `@Injectable()` decorator is **required for all services**." />
      <item value="Here is the revised `HeroService` that injects `Logger`, side by side with the previous service for comparison." />
      <item value="Service can have their own dependencies. `HeroService` is very simple and doesn't have any dependencies of its own. Suppose, however, that you want it to report its activities through a logging service. You can apply the same *constructor injection* pattern, adding a constructor that takes a `Logger` parameter." />
      <item value="Designing a class with dependency injection makes the class easier to test.&#10;Listing dependencies as constructor parameters may be all you need to test application parts effectively." />
      <item value="For example, Angular can inject `HeroListComponent` with both the `HeroService` provided in `HeroComponent` and the `UserService` provided in `AppModule`." />
      <item value="Thanks to [injector inheritance](guide/hierarchical-dependency-injection), you can still inject application-wide services into these components. A component's injector is a child of its parent component's injector, and a descendent of its parent's parent's injector, and so on all the way back to the application's _root_ injector. Angular can inject a service provided by any injector in that lineage." />
      <item value="Child modules and component injectors are independent of each other, and create their own separate instances of the provided services. When Angular destroys an NgModule or component instance, it also destroys that injector and that injector's service instances." />
      <item value="Angular DI has a [hierarchical injection system](guide/hierarchical-dependency-injection), which means that nested injectors can create their own service instances. Angular regularly creates nested injectors. Whenever Angular creates a new instance of a component that has `providers` specified in `@Component()`, it also creates a new _child injector_ for that instance.&#10;Similarly, when a new NgModule is lazy-loaded at run time, Angular can create an injector for it with its own providers." />
      <item value="There is only one root injector for an app. Providing `UserService` at the `root` or `AppModule` level means it is registered with the root injector. There is just one `UserService` instance in the entire app and every class that injects `UserService` gets this service instance _unless_ you configure another provider with a _child injector_." />
      <item value="`HeroService` must provided in some parent injector. The code in `HeroListComponent` doesn't depend on where `HeroService` comes from. If you decided to provide `HeroService` in `AppModule`, `HeroListComponent` wouldn't change." />
      <item value="`HeroService` must provided in some parent injector. The code in `HeroListComponent` doesn't depend on where `HeroService` comes from.&#10;If you decided to provide `HeroService` in `AppModule`, `HeroListComponent` wouldn't change." />
      <item value="Of course, `HeroListComponent` should do something with the injected `HeroService`.&#10;Here's the revised component, making use of the injected service, side-by-side with the previous version for comparison." />
      <item value="You can tell Angular to inject a dependency in a component's constructor by specifying a **constructor parameter with the dependency type**. Here's the `HeroListComponent` constructor, asking for the `HeroService` to be injected." />
      <item value="In order for `HeroListComponent` to get heroes from `HeroService`, it needs to ask for `HeroService` to be injected, rather than creating it's own `HeroService` instance with `new`." />
      <item value="Components are directives, and the `providers` option is inherited from `@Directive()`. You can also configure providers for directives and pipes at the same level as the component." />
      <item value="The `@Injectable()` decorator has the `providedIn` metadata option, where you can specify the provider of the decorated service class with the `root` injector, or with the injector for a specific NgModule." />
      <item value="Injectors are inherited, which means that if a given injector can't resolve a dependency, it asks the parent injector to resolve it. A component can get services from its own injector, from the injectors of its component ancestors, from the injector of its parent NgModule, or from the `root` injector." />
      <item value="A provider can be the service class itself, so that the injector can use `new` to create an instance.&#10;You might also define more than one class to provide the same service in different ways, and configure different injectors with different providers." />
      <item value="The injector is responsible for creating service instances and injecting them into classes like `HeroListComponent`. You rarely create an Angular injector yourself. Angular creates injectors for you as it executes the app, starting with the _root injector_ that it creates during the [bootstrap process](guide/bootstrapping)." />
      <item value="The class we have created provides a service. The `@Injectable()` decorator marks it as a service that can be injected, but Angular can't actually inject it anywhere until you configure an Angular [dependency injector](guide/glossary#injector) with a [provider](guide/glossary#provider) of that service." />
      <item value="The `@Injectable()` is an essential ingredient in every Angular service definition. The rest of the class has been written to expose a `getHeroes` method that returns the same mock data as before. (A real app would probably get its data asynchronously from a remote server, but we'll ignore that to focus on the mechanics of injecting the service.)" />
      <item value="It is possible to define the component first with the help of the `forwardRef()` method as explained in this [blog post](http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html)." />
      <item value="If you do combine a component and service in the same file, it is important to define the service first, and then the component. If you define the component before the service, you get a run-time null reference error." />
      <item value="Having multiple classes in the same file can be confusing. We generally recommend that you define components and services in separate files." />
      <item value="The DI framework lets you supply data to a component from an injectable _service_ class, defined in its own file. To demonstrate, we'll create an injectable service class that provides a list of heroes, and register that class as a provider of that service." />
      <item value="Start by reviewing this simplified version of the _heroes_ feature from the [The Tour of Heroes](tutorial/). This simple version doesn't use DI; we'll walk through converting it to do so." />
      <item value="In Angular, the DI framework provides declared dependencies to a class when that class is instantiated. This guide explains how DI works in Angular, and how you use it to make your apps flexible, efficient, and robust, as well as testable and maintainable." />
      <item value="Dependencies are services or objects that a class needs to perform its function. DI is a coding pattern in which a class asks for dependencies from external sources rather than creating them itself." />
      <item value="used in the design of Angular applications to increase their efficiency and modularity." />
      <item value="Using a class as an interface gives you the characteristics of an interface in a real JavaScript object. To minimize memory cost, however, the class should have *no implementation*. The `MinimalLogger` transpiles to this unoptimized, pre-minified JavaScript for a constructor function." />
      <item value="As mentioned in [DI Providers](guide/dependency-injection-providers#interface-not-valid-token), an interface is not a valid DI token because it is a TypeScript artifact that doesn't exist at run time. Use this abstract class interface to get the strong typing of an interface, and also use it as a provider token in the way you would a normal class." />
      <item value="Angular dependency injection is easiest when the provider token is a class that is also the type of the returned dependency object, or service." />
      <item value="The function retrieves candidate heroes from the `HeroService`, takes `2` of them to be the runners-up, and returns their concatenated names. Look at the &lt;live-example name=&quot;dependency-injection-in-action&quot;&gt;&lt;/live-example&gt; for the full source code." />
      <item value="In the example, the local state is the number `2`, the number of runners up that the component should show.&#10;The state value is passed as an argument to `runnersUpFactory()`.&#10;The `runnersUpFactory()` returns the *provider factory function*, which can use both the passed-in state value and the injected services `Hero` and `HeroService`." />
      <item value="The dependency object (returned by the factory function) is typically a class instance,&#10;but can be other things as well.&#10;In this example, the dependency object is a string of the names of the runners up to the &quot;Hero of the Month&quot; contest." />
      <item value="Behind the scenes, Angular sets the `logger` parameter to the full service registered under the `LoggingService` token, which happens to be the `DateLoggerService` instance that was [provided above](guide/dependency-injection-in-action#useclass)." />
      <item value="The `useExisting` provider key lets you map one token to another. In effect, the first token is an *alias* for the service associated with the second token, creating two ways to access the same service object." />
      <item value="You can use this type of provider to substitute an *alternative implementation* for a common or default class. The alternative implementation could, for example, implement a different strategy, extend the default class, or emulate the behavior of the real class in a test case." />
      <item value="The second specifies a literal string resource to use for the `TITLE` token. The `TITLE` provider token is *not* a class, but is instead a special kind of provider lookup key called an [injection token](guide/dependency-injection-in-action#injection-token), represented by an `InjectionToken` instance." />
      <item value="* The first provides an existing instance of the `Hero` class to use for the `Hero` token, rather than requiring the injector to create a new instance with `new` or use its own cached instance. Here, the token is the class itself." />
      <item value="The code behind it customizes how and where the DI framework provides dependencies.&#10;The use cases illustrate different ways to use the [*provide* object literal](guide/dependency-injection-providers#provide) to associate a definition object with a DI token." />
      <item value="A dependency can't always be created by the default method of instantiating a class.&#10;You learned about some other methods in [Dependency Providers](guide/dependency-injection-providers). The following `HeroOfTheMonthComponent` example demonstrates many of the alternatives and why you need them.&#10;It's visually simple: a few properties and the logs produced by a logger." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="394" />
        <entry key="ENGLISH" value="396" />
        <entry key="ROMANIAN" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
</application>