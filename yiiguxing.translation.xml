<application>
  <component name="AppStorage">
    <histories>
      <item value="## Configure size budgets" />
      <item value="You can also configure the `serve` command to use the targeted build configuration if you add it to the &quot;serve:configurations&quot; section of `angular.json`:" />
      <item value="This means that when you build your production configuration (using `ng build --prod` or `ng build --configuration=production`), the `src/environments/environment.ts` file is replaced with the target-specific version of the file, `src/environments/environment.prod.ts`." />
      <item value="The main CLI configuration file, `angular.json`, contains a `fileReplacements` section in the configuration for each build target, which allows you to replace any file with a target-specific version of that file. This is useful for including target-specific code or variables in a build that targets a specific environment, such as production or staging." />
      <item value="This ensures that the build and serve commands can find the configurations for specific build targets." />
      <item value="To use the environment configurations you have defined, your components must import the original environments file:" />
      <item value="This page discusses build-specific configuration options for Angular projects." />
      <item value="You can add target-specific configuration files, such as `environment.prod.ts`. The following sets content sets default values for the production build target:" />
      <item value="The `build` command uses this as the build target when no environment is specified. You can add further variables, either as additional properties on the environment object, or as separate objects. For example, the following adds a default for a variable to the default environment:" />
      <item value="The following figure shows how a project has multiple build targets, which can be executed using the named configurations that you define." />
      <item value="You develop apps in the context of an Angular [workspace](guide/glossary#workspace). A workspace contains the files for one or more [projects](guide/glossary#project). A project is the set of files that comprise a standalone app, a library, or a set of end-to-end (e2e) tests." />
      <item value="&lt;p&gt;List of components not referenced in any reachable template, for example dynamically created from code.&lt;/p&gt;" />
      <item value="Choosing a strategy begins with understanding the strengths and weaknesses of the options presented. Low-level API and form model access, predictability, mutability, straightforward validation and testing strategies, and scalability are all important consideration in choosing the infrastructure you use when building your forms in Angular. Template-driven forms are similar to patterns in AngularJS, but they have limitations given the criteria of many modern, large-scale Angular apps. Reactive forms integrate with reactive patterns already present in other areas of the Angular architecture, and complement those requirements well. Those limitations are alleviated with reactive forms." />
      <item value="## Final Thoughts" />
      <item value="**Template-driven** forms focus on simple scenarios, are not as reusable, abstract away the low-level APIs and access to the form model is provided asynchronously. The abstraction with template-driven forms surfaces in testing also, where testing reactive forms requires less setup and no dependence on the change detection cycle when updating and validating the form and data models during testing." />
      <item value="**Reactive forms** make creating large scale forms easier by providing access to low-level APIs and synchronous access to the form model." />
      <item value="If forms are a central part of your application, scalability is very important. Being able to reuse form models across components is critical." />
      <item value="With template-driven forms, the **favorite color property** is always modified to its new value." />
      <item value="With reactive forms, the **`FormControl` instance** always returns a new value when the control's value is updated." />
      <item value="The difference is demonstrated in the examples above using the **favorite color** input element." />
      <item value="**Template-driven** forms rely on mutability with two-way data binding to update the data model in the component as changes are made in the template. Because there are no unique changes to track on the data model when using two-way data binding, change detection is less efficient at determining when updates are required." />
      <item value="**Reactive forms** keep the data model pure by providing it as an immutable data structure. Each time a change is triggered on the data model, the `FormControl` instance returns a new data model rather than updating the data model directly. This gives you the ability track unique changes to the data model through the control's observable. This allows change detection to be more efficient because it only needs to update on unique changes. It also follows reactive patterns that integrate with observable operators to transform data." />
      <item value="How changes are tracked plays a role in the efficiency of your application." />
      <item value="Set the new value for the input is set to *Red*, and dispatch the &quot;input&quot; event on the form input element." />
      <item value="Query the view for the form input element, and create a custom &quot;input&quot; event for the test." />
      <item value="The following tests use the favorite color components mentioned earlier to verify the view to model and model to view data flows for a template-driven form." />
      <item value="Writing tests with template-driven forms requires more detailed knowledge of the change detection process and how directives run on each cycle to ensure elements are queried, tested, or changed at the correct time." />
      <item value="Assert that the new value set on the control matches the value in the input." />
      <item value="Query the view for the form input element." />
      <item value="Assert that the `favoriteColor` `FormControl` instance value matches the value from the input." />
      <item value="The steps performed in the view to model test." />
      <item value="The following tests use the favorite color components mentioned earlier to verify the view to model and model to view data flows for a reactive form." />
      <item value="Reactive forms provide a relatively easy testing strategy because they provide synchronous access to the form and data models, and they can be tested without rendering the UI. In these set of tests, controls and data are queried and manipulated through the control without interacting with the change detection cycle." />
      <item value="Testing also plays a large part in complex applications and an easier testing strategy is always welcomed. One difference in testing reactive forms and template-driven forms is their reliance on rendering the UI in order to perform assertions based on form control and form field changes. The following examples demonstrate the process of testing forms with reactive and template-driven forms." />
      <item value="**Template-driven forms** are tied to template **directives**, and must provide custom validator directives that wrap validation functions." />
      <item value="Validation is an integral part of managing any set of forms. Whether youâ€™re checking for required fields or querying an external API for an existing username, Angular provides a set of built-in validators as well as the ability to create custom validators." />
      <item value="The `FormControl` instance emits the latest value through the `valueChanges` observable." />
      <item value="The `ngOnChanges()` method queues an async task to set the value for the internal `FormControl` instance." />
      <item value="Because the component template uses two-way data binding for the `favoriteColor`, the `favoriteColor` property in the component is updated to the value emitted by the `ngModelChange` event (&quot;Blue&quot;)." />
      <item value="The control value accessor also calls the `NgModel.viewToModelUpdate()` method which emits an `ngModelChange` event." />
      <item value="Any subscribers to the `valueChanges` observable receive the new value." />
      <item value="The `FormControl` instance emits the new value through the `valueChanges` observable." />
      <item value="The control value accessor attached to the input triggers the `setValue()` method on the `FormControl` instance." />
      <item value="In template-driven forms, each form element is linked to a directive that manages the form model internally. The diagrams below uses the same favorite color example to demonstrate how data flows when an input field's value is changed from the view and then from the model." />
      <item value="The control value accessor on the form input element updates the element with the new value." />
      <item value="The `favoriteColorControl.setValue()` method is called, which updates the `FormControl` value." />
      <item value="The control value accessor listening for events on the form input element immediately relays the new value to the `FormControl` instance." />
      <item value="The steps below outline the view to model data flow." />
      <item value="As described above, in reactive forms each form element in the view is directly linked to a form model (`FormControl` instance). Updates from the view to model and model to view are synchronous and not dependent on the UI rendered. The diagrams below use the same favorite color example to demonstrate how data flows when an input field's value is changed from the view and then from the model." />
      <item value="When building forms in Angular, it's important to understand how the framework handles data flowing from the user or from programmatic changes. Reactive and template-driven forms follow two different strategies when handling form input. The data flow examples below begin with the favorite color input field example from above, and they show how changes to favorite color are handled in reactive forms compared to template-driven forms." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="590" />
        <entry key="ENGLISH" value="595" />
        <entry key="ROMANIAN" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
</application>