<application>
  <component name="AppStorage">
    <histories>
      <item value="Allows animations on child components to be run within the same timeframe as the parent." />
      <item value="Produces a reusable animation that can be invoked from elsewhere. Used together with &lt;code&gt;useAnimation()&lt;/code&gt;." />
      <item value="Staggers the starting time for animations for multiple elements." />
      <item value="Specifies a group of animation steps (&lt;em&gt;inner animations&lt;/em&gt;) to be run in parallel. Animation continues only after all inner animation steps have completed. Used within &lt;code&gt;sequence()&lt;/code&gt; or &lt;code&gt;transition().&lt;/code&gt;" />
      <item value="Allows a sequential change between styles within a specified time interval. Use within &lt;code&gt;animate()&lt;/code&gt;. Can include multiple &lt;code&gt;style()&lt;/code&gt; calls within each &lt;code&gt;keyframe()&lt;/code&gt;. Uses array syntax." />
      <item value="Creates a named set of CSS styles that should be applied on successful transition to a given state. The state can then be referenced by name within other animation functions." />
      <item value="Kicks off the animation and serves as a container for all other animation function calls. HTML template binds to &lt;code&gt;triggerName&lt;/code&gt;. Use the first argument to declare a unique trigger name. Uses array syntax." />
      <item value="The functional API provided by the `@angular/animations` module provides a domain-specific language (DSL) for creating and controlling animations in Angular applications. See the [API reference](api/animations) for a complete listing and syntax details of the core functions and related data structures." />
      <item value="For elements entering or leaving a page (inserted or removed from the DOM), you can make the animations conditional. For example, use `*ngIf` with the animation trigger in the HTML template." />
      <item value="In this example, when the `isOpen` expression evaluates to a defined state of `open` or `closed`, it notifies the trigger `openClose` of a state change. Then it's up to the `openClose` code to handle the state change and kick off a state change animation." />
      <item value="The `trigger()` function describes the property name to watch for changes. When a change occurs, the trigger initiates the actions included in its definition. These actions can be transitions or other functions, as we'll see later on." />
      <item value="* Use `transition()` to define intermediate styles, which create the illusion of motion during the animation." />
      <item value="This example adds a state transition from the `closed` state to the `open` state with a 0.5 second transition animation arc." />
      <item value="Natural easing curves" />
      <item value="* Wait for 100ms, run for 200ms. Use a deceleration curve to start out fast and slowly decelerate to a resting point: `'0.2s 100ms ease-out'`" />
      <item value="The `animate()` function (second argument of the transition function) accepts the `timings` and `styles` input parameters." />
      <item value="By default, all validators are run after every form value change. With synchronous validators, this will not likely have a noticeable impact on application performance. However, it's common for async validators to perform some kind of HTTP request to validate the control. Dispatching an HTTP request after every keystroke could put a strain on the backend API, and should be avoided if possible." />
      <item value="After some time passes, the observable chain completes and the async validation is done. The `pending` flag is set to `false`, and the form validity is updated." />
      <item value="Here we decided that `isAlterEgoTaken()` error is treated as a successful validation, because failure to make a validation request does not necessarily mean that the alter ego is invalid. You could handle the error differently and return the `ValidationError` object instead." />
      <item value="The `isAlterEgoTaken()` method dispatches an HTTP request that checks if the alter ego is available, and returns `Observable&lt;boolean&gt;` as the result. We pipe the response through the `map` operator and transform it into a validation result. As always, we return `null` if the form is valid, and `ValidationErrors` if it is not. We make sure to handle any potential errors with the `catchError` operator." />
      <item value="To validate the potential alter ego, we need to consult a central database of all currently enlisted heroes. The process is asynchronous, so we need a special validator for that." />
      <item value="In the following section, validation is performed asynchronously to ensure that our heroes pick an alter ego that is not already taken. New heroes are constantly enlisting and old heroes are leaving the service. That means that we do not have the list of available alter egos ahead of time." />
      <item value="A common UI pattern is to show a spinner while the async validation is being performed. The following example presents how to achieve this with template-driven forms:" />
      <item value="It is important to note that the asynchronous validation happens after the synchronous validation, and is performed only if the synchronous validation is successful. This check allows forms to avoid potentially expensive async validation processes such as an HTTP request if more basic validation methods fail." />
      <item value="Use the `animate()` function to define the length, delay, and easing of a transition, and to designate the style function for defining styles while transitions are taking place. You can also use the `animate()` function to define the `keyframes()` function for multi-step animations. These definitions are placed in the second argument of the `animate()` function." />
      <item value="To make the change less abrupt, we need to define an animation *transition* to specify the changes that occur between one state and another over a period of time. The `transition()` function accepts two arguments: the first argument accepts an expression that defines the direction between two transition states, and the second argument accepts an `animate()` function." />
      <item value="In Angular, you can set multiple styles without any animation. However, without further refinement, the button instantly transforms with no fade, no shrinkage, or other visible indicator that a change is occurring." />
      <item value="Let's see how Angular's `state()` function works with the `style⁣­(⁠)` function to set CSS style attributes. In this code snippet, multiple style attributes are set at the same time for the state. In the `open` state, the button has a height of 200 pixels, an opacity of 1, and a background color of yellow." />
      <item value="In HTML, these attributes are set using ordinary CSS styles such as color and opacity. In Angular, use the `style()` function to specify a set of CSS styles for use with animations. You can collect a set of styles in an animation state, and give the state a name, such as `open` or `closed`." />
      <item value="Prerequisites" />
      <item value="Angular's animation system is built on CSS functionality, which means you can animate any property that the browser considers animatable. This includes positions, sizes, transforms, colors, borders, and more. The W3C maintains a list of animatable properties on its [CSS Transitions](https://www.w3.org/TR/css-transitions-1/) page." />
      <item value="Typically, animations involve multiple style *transformations* over time. An HTML element can move, change color, grow or shrink, fade, or slide off the page. These changes can occur simultaneously or sequentially. You can control the timing of each transformation." />
      <item value="* Good animations intuitively call the user's attention to where it is needed." />
      <item value="* Motion greatly enhances the user experience, so animations give users a chance to detect the application's response to their actions." />
      <item value="* Without animations, web page transitions can seem abrupt and jarring." />
      <item value="Animation provides the illusion of motion: HTML elements change styling over time. Well-designed animations can make your application more fun and easier to use, but they aren't just cosmetic. Animations can improve your app and user experience in a number of ways:" />
      <item value="* Access the `ViewContainerRef` of an element by placing a `Directive` injected * with `ViewContainerRef` on the element, or use a `ViewChild` query." />
      <item value="A getter provides easy access to the aliases in the form array instance compared to repeating the `profileForm.get()` method to get each instance. The form array instance represents an undefined number of controls in an array. It's convenient to access a control through a getter, and this approach is easy to repeat for additional controls." />
      <item value="* Use the `patchValue()` method to replace any properties defined in the object that have changed in the form model." />
      <item value="The built-in browser DOM APIs don't automatically protect you from security vulnerabilities. For example, `document`, the node available through `ElementRef`, and many third-party APIs contain unsafe methods. In the same way, if you interact with other libraries that manipulate the DOM, you likely won't have the same automatic sanitization as with Angular interpolations. Avoid directly interacting with the DOM and instead use Angular templates where possible." />
      <item value="Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure." />
      <item value="&quot;organizations which design systems ... are constrained to produce designs which are copies of the communication structures of these organizations.&quot;" />
      <item value="The Angular CLI outputs the client-side code in the `dist` directory by default, so you modify the `outputPath` for the __build__ target in the `angular.json` to keep the client-side build outputs separate from the server-side code. The client-side build output will be served by the Express server." />
      <item value="A Universal app is distributed in two parts: the server-side code that serves up the initial application, and the client-side code that's loaded in dynamically." />
      <item value="`mat-typography-level-to-styles($config, $level)` - Mixin that takes in a configuration object and a typography level, and outputs a short-hand CSS `font` declaration." />
      <item value="Angular Material includes typography utility mixins and functions that you can use to customize your own components" />
      <item value="Angular Material includes typography utility mixins and functions that you can use to customize your&#10;own components:" />
      <item value="Typography customization is an extension of Angular Material's Sass-based theming. Similar to creating a custom theme, you can create a custom **typography configuration**." />
      <item value="host" />
      <item value="The typography levels are collected into a typography config which is used to generate the CSS." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="339" />
        <entry key="ENGLISH" value="341" />
        <entry key="ROMANIAN" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
</application>