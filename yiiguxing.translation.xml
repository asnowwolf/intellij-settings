<application>
  <component name="AppStorage">
    <histories>
      <item value="Here is a component with an input field for a single control implemented using reactive forms." />
      <item value="Reactive and template-driven forms both use a form model to track value changes between Angular forms and form input elements. The examples below show how the form model is defined and created." />
      <item value="How these control instances are created and managed with reactive and template-driven forms is introduced in the [form model setup](#setup-the-form-model) section below and detailed further in the [data flow section](#data-flow-in-forms) of this guide." />
      <item value="This guide provides information to help you decide which approach works best for your situation. It introduces the common building blocks used by both approaches. It also summarizes the key differences between the two approaches, and demonstrates those differences in the context of setup, data flow, and testing." />
      <item value="**Template-driven forms** are useful for adding a simple form to an app, such as an email list signup form. They are easy to add to an app, but they do not scale as well as reactive forms. If you have very basic form requirements and logic that can be managed solely in the template, use template-driven forms." />
      <item value="**Reactive forms** are more robust: they are more scalable, reusable, and testable. If forms are a key part of your application, or you're already using reactive patterns for building your application, use reactive forms." />
      <item value="Reactive and template-driven forms differ, however, in how they do the work of processing and managing forms and form data. Each offers different advantages." />
      <item value="Angular provides two different approaches to handling user input through forms: reactive and template-driven. Both capture user input events from the view, validate the user input, create a form model and data model to update, and provide a way to track changes." />
      <item value="Handling user input with forms is the cornerstone of many common applications. Applications use forms to enable users log in, to update a profile, to enter sensitive information, and to perform many other data-entry tasks." />
      <item value="Using `downgradeModule()` is a good option for hybrid apps when you want to keep the AngularJS and Angular parts less coupled. You can still mix and match components and services from both frameworks, but you might need to manually propagate change detection. In return, `downgradeModule()` offers more control and better performance." />
      <item value="It does not require you to change how you bootstrap your AngularJS app." />
      <item value="It improves performance by avoiding unnecessary change detection runs while giving the developer greater ability to customize." />
      <item value="It allows instantiating or even loading the Angular part lazily, which improves the initial loading time. In some cases this may waive the cost of running a second framework altogether." />
      <item value="To summarize, the key differentiating factors of `downgradeModule()` are:" />
      <item value="Specifically, this guide showed how you can achieve better performance and greater flexibility in your hybrid apps by using {@link downgradeModule downgradeModule()} instead of {@link UpgradeModule UpgradeModule}." />
      <item value="This page covered how to use the {@link upgrade/static upgrade/static} package to incrementally upgrade existing AngularJS apps at your own pace and without impeding further development of the app for the duration of the upgrade process." />
      <item value="And that is all you need to do to get the full benefit of AOT for hybrid Angular apps." />
      <item value="You also need to pass the generated `MainAngularModuleFactory` to `downgradeModule()` instead of the custom bootstrap function:" />
      <item value="You can take advantage of ahead-of-time (AOT) compilation in hybrid apps just like in any other Angular app. The setup for a hybrid app is mostly the same as described in the [Ahead-of-Time Compilation](guide/aot-compiler) guide save for differences in `index.html` and `main-aot.ts`." />
      <item value="## Using ahead-of-time compilation with hybrid apps" />
      <item value="For example, it is _OK_ to use a downgraded service in an upgraded component that is only used from Angular components, but it is _not OK_ to use it in an AngularJS component that may be used independently of Angular." />
      <item value="While it is possible to downgrade injectables, downgraded injectables will not be available until the Angular module is instantiated. In order to be safe, you need to ensure that the downgraded injectables are not used anywhere _outside_ the part of the app that is controlled by Angular." />
      <item value="The differences between `downgradeModule()` and `UpgradeModule` end here. The rest of the&#10;`upgrade/static` APIs and concepts work in the exact same way for both types of hybrid apps.&#10;See [Upgrading from AngularJS](guide/upgrade) to learn about:" />
      <item value="This bare minimum `NgModule` imports `BrowserModule`, the module every Angular browser-based app must have. It also defines an empty `ngDoBootstrap()` method, to prevent the {@link Compiler Compiler} from returning errors. This is necessary because the module will not have a `bootstrap` declaration on its `NgModule` decorator." />
      <item value="In order to start using any `upgrade/static` APIs, you still need to load the Angular framework as you would in a normal Angular app. You can see how this can be done with SystemJS by following the instructions in the [Setup](guide/setup) guide, selectively copying code from the [QuickStart github repository](https://github.com/angular/quickstart)." />
      <item value="As you might have guessed, you don't need to change anything in the way you bootstrap your existing AngularJS app. Unlike `UpgradeModule`&amp;mdash;which requires some extra steps&amp;mdash; `downgradeModule()` is able to take care of bootstrapping the Angular module, as long as you provide the recipe." />
      <item value="You use Angular for a feature that is not critical for the initial rendering of the app and you can afford a small delay in favor of better initial load performance." />
      <item value="You use Angular for features that are only visible to specific types of users; for example, logged-in users, administrators, or VIP members. You don't need to load Angular until a user is authenticated." />
      <item value="A few examples are:" />
      <item value="You could go a step further and not even download the code for the Angular part of the app to the user's browser until it is needed. This is especially useful when you use Angular on parts of the hybrid app that are not necessary for the initial rendering or that the user doesn't reach." />
      <item value="Another key difference between `downgradeModule()` and `UpgradeModule` is that the latter requires you to instantiate both the AngularJS and Angular modules up-front. This means that you have to pay the cost of instantiating the Angular part of the app, even if you don't use any Angular assets until later. `downgradeModule()` is again less aggressive. It will only instantiate the Angular part when it is required for the first time; that is, as soon as it needs to create a downgraded component." />
      <item value="#### Instantiating the Angular module on-demand" />
      <item value="Using an `NgModuleFactory` requires less boilerplate and is a good default option as it supports AOT out-of-the-box. Using a custom function requires slightly more code, but gives you greater flexibility." />
      <item value="Alternatively, you can pass a plain function, which is expected to return a promise resolving to an {@link NgModuleRef NgModuleRef} (i.e. an instance of your Angular module). The function is called with an array of extra {@link StaticProvider Providers} that are expected to be available on the returned `NgModuleRef`'s {@link Injector Injector}. For example, if you are using {@link platformBrowser platformBrowser} or {@link platformBrowserDynamic platformBrowserDynamic}, you can pass the `extraProviders` array to them:" />
      <item value="When you pass an `NgModuleFactory`, `downgradeModule()` uses it to instantiate the module using {@link platformBrowser platformBrowser}'s {@link PlatformRef#bootstrapModuleFactory bootstrapModuleFactory()}, which is compatible with ahead-of-time (AOT) compilation. AOT compilation helps make your apps load faster. For more about AOT and how to create an `NgModuleFactory`, see the [Ahead-of-Time Compilation](guide/aot-compiler) guide." />
      <item value="As mentioned earlier, `downgradeModule()` needs to know how to instantiate the Angular module. It needs a recipe. You define that recipe by providing a factory function that can create an instance of the Angular module. `downgradeModule()` accepts two types of factory functions:" />
      <item value="There are a few things to note, though:" />
      <item value="An important part of inter-linking dependencies is linking the two main modules together. This is where `downgradeModule()` comes in. Use it to create an AngularJS module&amp;mdash;one that you can use as a dependency in your main AngularJS module&amp;mdash;that will bootstrap your main Angular module and kick off the Angular part of the hybrid app. In a sense, it &quot;downgrades&quot; an Angular module to an AngularJS module." />
      <item value="For the most part, you specify the modules in the same way you would for a regular app. Then, you use the `upgrade/static` helpers to let the two frameworks know about assets they can use from each other. This is known as &quot;upgrading&quot; and &quot;downgrading&quot;." />
      <item value="Their details are quite different in architecture and implementation. In AngularJS, you create a module by specifying its name and dependencies with [angular.module()](https://docs.angularjs.org/api/ng/function/angular.module). Then you can add assets using its various methods. In Angular, you create a class adorned with an {@link NgModule NgModule} decorator that describes assets in metadata." />
      <item value="Both AngularJS and Angular have their own concept of modules to help organize an app into cohesive blocks of functionality." />
      <item value="In many cases, a few extra change detection runs may not matter much. However, on larger or change-detection-heavy apps they can have a noticeable impact. By giving you more fine-grained control over the change detection propagation, `downgradeModule()` allows you to achieve better performance for your hybrid apps." />
      <item value="If you want a particular piece of code to trigger change detection in the AngularJS part of the app, you need to wrap it in [scope.$apply()](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply). Similarly, for triggering change detection in Angular you would use {@link NgZone#run ngZone.run()}." />
      <item value="In most cases, though, the changes made locally in a particular component are of no interest to the rest of the app. For example, if the user clicks a button that submits a form, the component usually handles the result of this action. That being said, there _are_ cases where you want to propagate changes to some other part of the app that may be controlled by the other framework. In such cases, you are responsible for notifying the interested parties by manually triggering change detection." />
      <item value="`downgradeModule()`, on the other side, avoids explicitly triggering change detection unless it knows the other part of the app is interested in the changes. For example, if a downgraded component defines an `@Input()`, chances are that the app needs to be aware when that value changes. Thus, `downgradeComponent()` automatically triggers change detection on that component." />
      <item value="The [Change Detection](guide/upgrade#change-detection) section of [Upgrading from AngularJS](guide/upgrade) only applies to apps that use `UpgradeModule`. Though you handle change detection differently with `downgradeModule()`, which is the focus of this guide, reading the [Change Detection](guide/upgrade#change-detection) section provides helpful context for what follows." />
      <item value="Regardless of whether you choose `downgradeModule()` or `UpgradeModule`, the basic principles of upgrading, the mental model behind hybrid apps, and how you use the {@link upgrade/static upgrade/static} utilities remain the same. For more information, see the [How `ngUpgrade` Works](guide/upgrade#how-ngupgrade-works) section of [Upgrading from AngularJS](guide/upgrade)." />
      <item value="With the `ngUpgrade` library in Angular you can upgrade an existing AngularJS app incrementally by building a hybrid app where you can run both frameworks side-by-side. In these hybrid apps you can mix and match AngularJS and Angular components and services and have them interoperate seamlessly. That means you don't have to do the upgrade work all at once as there is a natural coexistence between the two frameworks during the transition period." />
      <item value="Before discussing how you can use `downgradeModule()` to create hybrid apps, there are things that you can do to ease the upgrade process even before you begin upgrading. Because the steps are the same regardless of how you upgrade, refer to the [Preparation](guide/upgrade#preparation) section of [Upgrading from AngularJS](guide/upgrade)." />
      <item value="This guide describes some of the built-in tools for efficiently migrating AngularJS projects over to the Angular platform, one piece at a time. It is very similar to [Upgrading from AngularJS](guide/upgrade) with the exception that this one uses the {@link downgradeModule downgradeModule()} helper function instead of the {@link UpgradeModule UpgradeModule} class. This affects how the app is bootstrapped and how change detection is propagated between the two frameworks. It allows you to upgrade incrementally while improving the speed of your hybrid apps and leveraging the latest of Angular in AngularJS apps early in the process of upgrading." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="557" />
        <entry key="ENGLISH" value="561" />
        <entry key="ROMANIAN" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
</application>