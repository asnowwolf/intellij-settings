<application>
  <component name="AppStorage">
    <histories>
      <item value="For example, Angular can inject `HeroListComponent` with both the `HeroService` provided in `HeroComponent` and the `UserService` provided in `AppModule`." />
      <item value="Thanks to [injector inheritance](guide/hierarchical-dependency-injection), you can still inject application-wide services into these components. A component's injector is a child of its parent component's injector, and a descendent of its parent's parent's injector, and so on all the way back to the application's _root_ injector. Angular can inject a service provided by any injector in that lineage." />
      <item value="Child modules and component injectors are independent of each other, and create their own separate instances of the provided services. When Angular destroys an NgModule or component instance, it also destroys that injector and that injector's service instances." />
      <item value="Angular DI has a [hierarchical injection system](guide/hierarchical-dependency-injection), which means that nested injectors can create their own service instances. Angular regularly creates nested injectors. Whenever Angular creates a new instance of a component that has `providers` specified in `@Component()`, it also creates a new _child injector_ for that instance.&#10;Similarly, when a new NgModule is lazy-loaded at run time, Angular can create an injector for it with its own providers." />
      <item value="There is only one root injector for an app. Providing `UserService` at the `root` or `AppModule` level means it is registered with the root injector. There is just one `UserService` instance in the entire app and every class that injects `UserService` gets this service instance _unless_ you configure another provider with a _child injector_." />
      <item value="`HeroService` must provided in some parent injector. The code in `HeroListComponent` doesn't depend on where `HeroService` comes from. If you decided to provide `HeroService` in `AppModule`, `HeroListComponent` wouldn't change." />
      <item value="`HeroService` must provided in some parent injector. The code in `HeroListComponent` doesn't depend on where `HeroService` comes from.&#10;If you decided to provide `HeroService` in `AppModule`, `HeroListComponent` wouldn't change." />
      <item value="Of course, `HeroListComponent` should do something with the injected `HeroService`.&#10;Here's the revised component, making use of the injected service, side-by-side with the previous version for comparison." />
      <item value="You can tell Angular to inject a dependency in a component's constructor by specifying a **constructor parameter with the dependency type**. Here's the `HeroListComponent` constructor, asking for the `HeroService` to be injected." />
      <item value="In order for `HeroListComponent` to get heroes from `HeroService`, it needs to ask for `HeroService` to be injected, rather than creating it's own `HeroService` instance with `new`." />
      <item value="Components are directives, and the `providers` option is inherited from `@Directive()`. You can also configure providers for directives and pipes at the same level as the component." />
      <item value="The `@Injectable()` decorator has the `providedIn` metadata option, where you can specify the provider of the decorated service class with the `root` injector, or with the injector for a specific NgModule." />
      <item value="Injectors are inherited, which means that if a given injector can't resolve a dependency, it asks the parent injector to resolve it. A component can get services from its own injector, from the injectors of its component ancestors, from the injector of its parent NgModule, or from the `root` injector." />
      <item value="A provider can be the service class itself, so that the injector can use `new` to create an instance.&#10;You might also define more than one class to provide the same service in different ways, and configure different injectors with different providers." />
      <item value="The injector is responsible for creating service instances and injecting them into classes like `HeroListComponent`. You rarely create an Angular injector yourself. Angular creates injectors for you as it executes the app, starting with the _root injector_ that it creates during the [bootstrap process](guide/bootstrapping)." />
      <item value="The class we have created provides a service. The `@Injectable()` decorator marks it as a service that can be injected, but Angular can't actually inject it anywhere until you configure an Angular [dependency injector](guide/glossary#injector) with a [provider](guide/glossary#provider) of that service." />
      <item value="The `@Injectable()` is an essential ingredient in every Angular service definition. The rest of the class has been written to expose a `getHeroes` method that returns the same mock data as before. (A real app would probably get its data asynchronously from a remote server, but we'll ignore that to focus on the mechanics of injecting the service.)" />
      <item value="It is possible to define the component first with the help of the `forwardRef()` method as explained in this [blog post](http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html)." />
      <item value="If you do combine a component and service in the same file, it is important to define the service first, and then the component. If you define the component before the service, you get a run-time null reference error." />
      <item value="Having multiple classes in the same file can be confusing. We generally recommend that you define components and services in separate files." />
      <item value="The DI framework lets you supply data to a component from an injectable _service_ class, defined in its own file. To demonstrate, we'll create an injectable service class that provides a list of heroes, and register that class as a provider of that service." />
      <item value="Start by reviewing this simplified version of the _heroes_ feature from the [The Tour of Heroes](tutorial/). This simple version doesn't use DI; we'll walk through converting it to do so." />
      <item value="In Angular, the DI framework provides declared dependencies to a class when that class is instantiated. This guide explains how DI works in Angular, and how you use it to make your apps flexible, efficient, and robust, as well as testable and maintainable." />
      <item value="Dependencies are services or objects that a class needs to perform its function. DI is a coding pattern in which a class asks for dependencies from external sources rather than creating them itself." />
      <item value="used in the design of Angular applications to increase their efficiency and modularity." />
      <item value="Using a class as an interface gives you the characteristics of an interface in a real JavaScript object. To minimize memory cost, however, the class should have *no implementation*. The `MinimalLogger` transpiles to this unoptimized, pre-minified JavaScript for a constructor function." />
      <item value="As mentioned in [DI Providers](guide/dependency-injection-providers#interface-not-valid-token), an interface is not a valid DI token because it is a TypeScript artifact that doesn't exist at run time. Use this abstract class interface to get the strong typing of an interface, and also use it as a provider token in the way you would a normal class." />
      <item value="Angular dependency injection is easiest when the provider token is a class that is also the type of the returned dependency object, or service." />
      <item value="The function retrieves candidate heroes from the `HeroService`, takes `2` of them to be the runners-up, and returns their concatenated names. Look at the &lt;live-example name=&quot;dependency-injection-in-action&quot;&gt;&lt;/live-example&gt; for the full source code." />
      <item value="In the example, the local state is the number `2`, the number of runners up that the component should show.&#10;The state value is passed as an argument to `runnersUpFactory()`.&#10;The `runnersUpFactory()` returns the *provider factory function*, which can use both the passed-in state value and the injected services `Hero` and `HeroService`." />
      <item value="The dependency object (returned by the factory function) is typically a class instance,&#10;but can be other things as well.&#10;In this example, the dependency object is a string of the names of the runners up to the &quot;Hero of the Month&quot; contest." />
      <item value="Behind the scenes, Angular sets the `logger` parameter to the full service registered under the `LoggingService` token, which happens to be the `DateLoggerService` instance that was [provided above](guide/dependency-injection-in-action#useclass)." />
      <item value="The `useExisting` provider key lets you map one token to another. In effect, the first token is an *alias* for the service associated with the second token, creating two ways to access the same service object." />
      <item value="You can use this type of provider to substitute an *alternative implementation* for a common or default class. The alternative implementation could, for example, implement a different strategy, extend the default class, or emulate the behavior of the real class in a test case." />
      <item value="The second specifies a literal string resource to use for the `TITLE` token. The `TITLE` provider token is *not* a class, but is instead a special kind of provider lookup key called an [injection token](guide/dependency-injection-in-action#injection-token), represented by an `InjectionToken` instance." />
      <item value="* The first provides an existing instance of the `Hero` class to use for the `Hero` token, rather than requiring the injector to create a new instance with `new` or use its own cached instance. Here, the token is the class itself." />
      <item value="The code behind it customizes how and where the DI framework provides dependencies.&#10;The use cases illustrate different ways to use the [*provide* object literal](guide/dependency-injection-providers#provide) to associate a definition object with a DI token." />
      <item value="A dependency can't always be created by the default method of instantiating a class.&#10;You learned about some other methods in [Dependency Providers](guide/dependency-injection-providers). The following `HeroOfTheMonthComponent` example demonstrates many of the alternatives and why you need them.&#10;It's visually simple: a few properties and the logs produced by a logger." />
      <item value="A new injector has no providers.&#10;Angular initializes the injectors it creates with a set of preferred providers.&#10;You have to configure providers for your own app-specific dependencies." />
      <item value="Angular usually handles this transaction by specifying a constructor parameter and its type." />
      <item value="Using the `@Self` decorator, the injector only looks at the component's injector for its providers. The `@SkipSelf` decorator allows you to skip the local injector and look up in the hierarchy to find a provider that satisfies this dependency. The `sessionStorageService` instance interacts with the `BrowserStorageService` using the `sessionStorage` browser API, while the `localStorageService` skips the local injector and uses the root `BrowserStorageService` that uses the `localStorage` browswer API." />
      <item value="Providers can also be scoped by injector through constructor parameter decorators. The following example overrides the `BROWSER_STORAGE` token in the `Component` class `providers` with the `sessionStorage` browser API. The same `BrowserStorageService` is injected twice in the constructor, decorated with `@Self` and `@SkipSelf` to define which injector handles the provider dependency." />
      <item value="The `factory` function returns the `localStorage` property that is attached to the browser window object. The `Inject` decorator is a constructor parameter used to specify a custom provider of a dependency. This custom provider can now be overridden during testing with a mock API of `localStorage` instead of interactive with real browser APIs." />
      <item value="Using a custom provider allows you to provide a concrete implementation for implicit dependencies, such as built-in browser APIs. The following example uses an `InjectionToken` to provide the [localStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) browser API as a dependency in the `BrowserStorageService`." />
      <item value="The following example covers this second case." />
      <item value="In some cases, you need to limit the search or accommodate a missing dependency. You can modify Angular's search behavior with the `@Host` and `@Optional` qualifying decorators on a service-valued parameter of the component's constructor." />
      <item value="When a class requires a dependency, that dependency is added to the constructor as a parameter. When Angular needs to instantiate the class, it calls upon the DI framework to supply the dependency. By default, the DI framework searches for a provider in the injector hierarchy, starting at the component's local injector of the component, and if necessary bubbling up through the injector tree until it reaches the root injector." />
      <item value="Tells the compiler to generate all the possible generated files even if they are empty. This option is `false` by default. This is an option used by the Bazel build rules and is needed to simplify how Bazel rules track file dependencies. It is not recommended to use this option outside of the Bazel rules." />
      <item value="This option tells the compiler whether to remove blank text nodes from compiled templates. As of v6, this option is `false` by default, which results in smaller emitted template factory modules." />
      <item value="The Angular template compiler transforms code that is used, or could be used, in an annotation to allow it to be imported from template factory modules. See [metadata rewriting](#metadata-rewriting) for more information." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="388" />
        <entry key="ENGLISH" value="390" />
        <entry key="ROMANIAN" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
</application>