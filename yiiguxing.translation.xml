<application>
  <component name="AppStorage">
    <histories>
      <item value="Using a class as an interface gives you the characteristics of an interface in a real JavaScript object. To minimize memory cost, however, the class should have *no implementation*. The `MinimalLogger` transpiles to this unoptimized, pre-minified JavaScript for a constructor function." />
      <item value="As mentioned in [DI Providers](guide/dependency-injection-providers#interface-not-valid-token), an interface is not a valid DI token because it is a TypeScript artifact that doesn't exist at run time. Use this abstract class interface to get the strong typing of an interface, and also use it as a provider token in the way you would a normal class." />
      <item value="Angular dependency injection is easiest when the provider token is a class that is also the type of the returned dependency object, or service." />
      <item value="The function retrieves candidate heroes from the `HeroService`, takes `2` of them to be the runners-up, and returns their concatenated names. Look at the &lt;live-example name=&quot;dependency-injection-in-action&quot;&gt;&lt;/live-example&gt; for the full source code." />
      <item value="In the example, the local state is the number `2`, the number of runners up that the component should show.&#10;The state value is passed as an argument to `runnersUpFactory()`.&#10;The `runnersUpFactory()` returns the *provider factory function*, which can use both the passed-in state value and the injected services `Hero` and `HeroService`." />
      <item value="The dependency object (returned by the factory function) is typically a class instance,&#10;but can be other things as well.&#10;In this example, the dependency object is a string of the names of the runners up to the &quot;Hero of the Month&quot; contest." />
      <item value="Behind the scenes, Angular sets the `logger` parameter to the full service registered under the `LoggingService` token, which happens to be the `DateLoggerService` instance that was [provided above](guide/dependency-injection-in-action#useclass)." />
      <item value="The `useExisting` provider key lets you map one token to another. In effect, the first token is an *alias* for the service associated with the second token, creating two ways to access the same service object." />
      <item value="You can use this type of provider to substitute an *alternative implementation* for a common or default class. The alternative implementation could, for example, implement a different strategy, extend the default class, or emulate the behavior of the real class in a test case." />
      <item value="The second specifies a literal string resource to use for the `TITLE` token. The `TITLE` provider token is *not* a class, but is instead a special kind of provider lookup key called an [injection token](guide/dependency-injection-in-action#injection-token), represented by an `InjectionToken` instance." />
      <item value="* The first provides an existing instance of the `Hero` class to use for the `Hero` token, rather than requiring the injector to create a new instance with `new` or use its own cached instance. Here, the token is the class itself." />
      <item value="The code behind it customizes how and where the DI framework provides dependencies.&#10;The use cases illustrate different ways to use the [*provide* object literal](guide/dependency-injection-providers#provide) to associate a definition object with a DI token." />
      <item value="A dependency can't always be created by the default method of instantiating a class.&#10;You learned about some other methods in [Dependency Providers](guide/dependency-injection-providers). The following `HeroOfTheMonthComponent` example demonstrates many of the alternatives and why you need them.&#10;It's visually simple: a few properties and the logs produced by a logger." />
      <item value="A new injector has no providers.&#10;Angular initializes the injectors it creates with a set of preferred providers.&#10;You have to configure providers for your own app-specific dependencies." />
      <item value="Angular usually handles this transaction by specifying a constructor parameter and its type." />
      <item value="Using the `@Self` decorator, the injector only looks at the component's injector for its providers. The `@SkipSelf` decorator allows you to skip the local injector and look up in the hierarchy to find a provider that satisfies this dependency. The `sessionStorageService` instance interacts with the `BrowserStorageService` using the `sessionStorage` browser API, while the `localStorageService` skips the local injector and uses the root `BrowserStorageService` that uses the `localStorage` browswer API." />
      <item value="Providers can also be scoped by injector through constructor parameter decorators. The following example overrides the `BROWSER_STORAGE` token in the `Component` class `providers` with the `sessionStorage` browser API. The same `BrowserStorageService` is injected twice in the constructor, decorated with `@Self` and `@SkipSelf` to define which injector handles the provider dependency." />
      <item value="The `factory` function returns the `localStorage` property that is attached to the browser window object. The `Inject` decorator is a constructor parameter used to specify a custom provider of a dependency. This custom provider can now be overridden during testing with a mock API of `localStorage` instead of interactive with real browser APIs." />
      <item value="Using a custom provider allows you to provide a concrete implementation for implicit dependencies, such as built-in browser APIs. The following example uses an `InjectionToken` to provide the [localStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) browser API as a dependency in the `BrowserStorageService`." />
      <item value="The following example covers this second case." />
      <item value="In some cases, you need to limit the search or accommodate a missing dependency. You can modify Angular's search behavior with the `@Host` and `@Optional` qualifying decorators on a service-valued parameter of the component's constructor." />
      <item value="When a class requires a dependency, that dependency is added to the constructor as a parameter. When Angular needs to instantiate the class, it calls upon the DI framework to supply the dependency. By default, the DI framework searches for a provider in the injector hierarchy, starting at the component's local injector of the component, and if necessary bubbling up through the injector tree until it reaches the root injector." />
      <item value="Tells the compiler to generate all the possible generated files even if they are empty. This option is `false` by default. This is an option used by the Bazel build rules and is needed to simplify how Bazel rules track file dependencies. It is not recommended to use this option outside of the Bazel rules." />
      <item value="This option tells the compiler whether to remove blank text nodes from compiled templates. As of v6, this option is `false` by default, which results in smaller emitted template factory modules." />
      <item value="The Angular template compiler transforms code that is used, or could be used, in an annotation to allow it to be imported from template factory modules. See [metadata rewriting](#metadata-rewriting) for more information." />
      <item value="Use of the `&lt;template&gt;` element was deprecated starting in Angular 4.0 in favor of using `&lt;ng-template&gt;` to avoid colliding with the DOM's element of the same name. Setting this option to `true` enables the use of the deprecated `&lt;template&gt;` element. This option is `false` by default. This option might be required by some third-party Angular libraries." />
      <item value="Replace decorators with a static field in the class. Allows advanced tree-shakers like &lt;a href=&quot;https://github.com/google/closure-compiler&quot;&gt;Closure compiler&lt;/a&gt; to remove unused classes." />
      <item value="Leave the decorators in place. This makes compilation faster. TypeScript will emit calls to the __decorate helper. Use &lt;code&gt;--emitDecoratorMetadata&lt;/code&gt; for runtime reflection. However, the resulting code will not properly tree-shake." />
      <item value="Use this option to modify how the Angular specific annotations are emitted to improve tree-shaking. Non-Angular annotations and decorators are unaffected. Default is `static fields`." />
      <item value="This option tells the compiler to use [Tsickle](https://github.com/angular/tsickle) to annotate the emitted JavaScript with [JSDoc](http://usejsdoc.org/) comments needed by the [Closure Compiler](https://github.com/google/closure-compiler). This option defaults to `false`." />
      <item value="This option tells the template compiler to generate factory files (`.ngfactory.js` and `.ngstyle.js`) for `.d.ts` files with a corresponding `.metadata.json` file. This option defaults to `true`. When this option is `false`, factory files are generated only for `.ts` files." />
      <item value="This option specifies the preferred module id to use for importing a flat module. References generated by the template compiler will use this module name when importing symbols from the flat module. This is only meaningful when `flatModuleOutFile` is also supplied. Otherwise the compiler ignores this option." />
      <item value="By default the `.ts` file supplied in the `files` field is assumed to be the library index. If more than one `.ts` file is specified, `libraryIndex` is used to select the file to use. If more than one `.ts` file is supplied without a `libraryIndex`, an error is produced. A flat module index `.d.ts` and `.js` will be created with the given `flatModuleOutFile` name in the same location as the library index `.d.ts` file. For example, if a library uses the `public_api.ts` file as the library index of the module, the `tsconfig.json` `files` field would be `[&quot;public_api.ts&quot;]`. The `flatModuleOutFile` options could then be set to, for example `&quot;index.js&quot;`, which produces `index.d.ts` and `index.metadata.json` files. The library's `package.json`'s `module` field would be `&quot;index.js&quot;` and the `typings` field would be `&quot;index.d.ts&quot;`." />
      <item value="When set to `true`, this option tells the template compiler to generate a flat module index of the given file name and the corresponding flat module metadata. Use this option when creating flat modules that are packaged similarly to `@angular/core` and `@angular/common`. When this option is used, the `package.json` for the library should refer to the generated flat module index instead of the library index file. With this option only one `.metadata.json` file is produced, which contains all the metadata necessary for symbols exported from the library index. In the generated `.ngfactory.js` files, the flat module index is used to import symbols that includes both the public API from the library index as well as shrowded internal symbols." />
      <item value="When set to `true`, this option tells the template compiler to generate a flat module&#10;index of the given file name and the corresponding flat module metadata. Use this option when creating flat modules that are packaged similarly to `@angular/core` and `@angular/common`. When this option is used, the `package.json` for the library should refer to the generated flat module index instead of the library index file. With this option only one `.metadata.json` file is produced, which contains all the metadata necessary for symbols exported from the library index. In the generated `.ngfactory.js` files, the flat module index is used to import symbols that includes both the public API from the library index as well as shrowded internal symbols." />
      <item value="*Note*: It is recommended to change this option explicitly to `true` as this option will default to `true` in the future." />
      <item value="When set to `true`, this options tells the compiler to report an error for a parameter supplied whose injection type cannot be determined. When this option is not provided or is `false`, constructor parameters of classes marked with `@Injectable` whose type cannot be resolved will produce a warning." />
      <item value="This option tells the compiler to suppress emitting `.ngfactory.js` and `.ngstyle.js` files. When set, this turns off most of the template compiler and disables reporting template diagnostics. This option can be used to instruct the template compiler to produce `.metadata.json` files for distribution with an `npm` package while avoiding the production of `.ngfactory.js` and `.ngstyle.js` files that cannot be distributed to `npm`." />
      <item value="It is valid for `.metadata.json` files to contain errors. The template compiler reports these errors if the metadata is used to determine the contents of an annotation. The metadata collector cannot predict the symbols that are designed for use in an annotation, so it will preemptively include error nodes in the metadata for the exported symbols. The template compiler can then use the error nodes to report an error if these symbols are used. If the client of a library intends to use a symbol in an annotation, the template compiler will not normally report this until the client uses the symbol. This option allows detecting these errors during the build phase of the library and is used, for example, in producing Angular libraries themselves." />
      <item value="It is valid for `.metadata.json` files to contain errors. The template compiler reports these errors&#10;if the metadata is used to determine the contents of an annotation. The metadata&#10;collector cannot predict the symbols that are designed for use in an annotation, so it will preemptively&#10;include error nodes in the metadata for the exported symbols. The template compiler can then use the error&#10;nodes to report an error if these symbols are used. If the client of a library intends to use a symbol in an annotation, the template compiler will not normally report&#10;this until the client uses the symbol. This option allows detecting these errors during the build phase of&#10;the library and is used, for example, in producing Angular libraries themselves." />
      <item value="This option is intended to validate the `.metadata.json` files emitted for bundling with an `npm` package. The validation is strict and can emit errors for metadata that would never produce an error when used by the template compiler. You can choose to suppress the error emitted by this option for an exported symbol by including `@dynamic` in the comment documenting the symbol." />
      <item value="This option tells the template compiler to report an error to the `.metadata.json`&#10;file if `&quot;skipMetadataEmit&quot;` is `false`. This option is `false` by default. This should only be used when `&quot;skipMetadataEmit&quot;` is `false` and `&quot;skipTemplateCodeGen&quot;` is `true`." />
      <item value="This option can also be set to `true` when using factory summaries because the factory summaries&#10;include a copy of the information that is in the `.metadata.json` file." />
      <item value="`.metadata.json` files contain information needed by the template compiler from a `.ts`&#10;file that is not included in the `.d.ts` file produced by the TypeScript compiler. This information contains,&#10;for example, the content of annotations (such as a component's template), which TypeScript&#10;emits to the `.js` file but not to the `.d.ts` file." />
      <item value="This option instructs the compiler to replace the `templateUrl` and `styleUrls` property in all `@Component` decorators with inlined contents in `template` and `styles` properties.&#10;When enabled, the `.js` output of `ngc` will have no lazy-loaded `templateUrl` or `styleUrls`." />
      <item value="The template compiler options are specified as members of the `&quot;angularCompilerOptions&quot;` object in the `tsconfig.json` file. Specify template compiler options along with the options supplied to the TypeScript compiler as shown here:" />
      <item value="Similar to TypeScript Compiler, Angular Compiler also supports `extends` in the `tsconfig.json` on `angularCompilerOptions`. A tsconfig file can inherit configurations from another file using the `extends` property. The `extends` is a top level property parallel to `compilerOptions` and `angularCompilerOptions`. The configuration from the base file are loaded first, then overridden by those in the inheriting config file. Example:" />
      <item value="## Configuration inheritance with extends" />
      <item value="The file name reported in the error message, `my.component.ts.MyComponent.html`, is a synthetic file generated by the template compiler that holds contents of the `MyComponent` class template. Compiler never writes this file to disk. The line and column numbers are relative to the template string in the `@Component` annotation of the class, `MyComponent` in this case. If a component uses `templateUrl` instead of `template`, the errors are reported in the HTML file referenced by the `templateUrl` instead of a synthetic file." />
      <item value="_Tagged template expressions are not supported in metadata._" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="384" />
        <entry key="ENGLISH" value="386" />
        <entry key="ROMANIAN" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
</application>