<application>
  <component name="AppStorage">
    <histories>
      <item value="In development, you typically start the server in the folder that holds `index.html`.&#10;That's the root folder and you'd add `&lt;base href=&quot;/&quot;&gt;` near the top of `index.html` because `/` is the root of the app." />
      <item value="The HTML [_&amp;lt;base href=&quot;...&quot;/&amp;gt;_](/guide/router) specifies a base path for resolving relative URLs to assets such as images, scripts, and style sheets. For example, given the `&lt;base href=&quot;/my/app/&quot;&gt;`, the browser resolves a URL such as `some/place/foo.jpg` into a server request for `my/app/some/place/foo.jpg`. During navigation, the Angular router uses the _base href_ as the base path to component, template, and module files." />
      <item value="Run the explorer to generate a graphical representation of one of the bundles.&#10;The following example displays the graph for the _main_ bundle." />
      <item value="### Inspect the bundles" />
      <item value="The [WebPageTest](https://www.webpagetest.org/) tool is another good choice&#10;that can also help verify that your deployment was successful." />
      <item value="You can make better decisions about what to optimize and how when you have a clear and accurate understanding of what's making the application slow. The cause may not be what you think it is. You can waste a lot of time and money optimizing something that has no tangible benefit or even makes the app slower. You should measure the app's actual behavior when running in the environments that are important to you. The &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/network-performance/understanding-resource-timing&quot; title=&quot;Chrome DevTools Network Performance&quot;&gt; Chrome DevTools Network Performance page&lt;/a&gt; is a good place to start learning about measuring performance." />
      <item value="### Measure performance" />
      <item value="The bundling configuration must take lazy loading into consideration.&#10;Because lazy-loaded modules aren't imported in JavaScript, bundlers exclude them by default.&#10;Bundlers don't know about the router configuration and can't create separate bundles for lazy-loaded modules. You would have to create these bundles manually." />
      <item value="If you mean to lazy-load a module, be careful not import it in a file that's eagerly loaded when the app starts (such as the root `AppModule`). If you do that, the module will be loaded immediately." />
      <item value="#### Don't eagerly import something from a lazy-loaded module" />
      <item value="Configure the Angular Router to defer loading of all other modules (and their associated code), either by [waiting until the app has launched](guide/router#preloading &quot;Preloading&quot;) or by [_lazy loading_](guide/router#asynchronous-routing &quot;Lazy loading&quot;) them on demand." />
      <item value="* Dead code elimination: removes unreferenced modules and much unused code." />
      <item value="* Uglification: rewrites code to use short, cryptic variable and function names." />
      <item value="* Minification: removes excess whitespace, comments, and optional tokens." />
      <item value="The `--prod` _meta-flag_ engages the following optimization features." />
      <item value="Although deploying directly from the development environment works, you can generate an optimized build with additional CLI command line flags, starting with `--prod`." />
      <item value="Make a note of the user name and project name in GitHub." />
      <item value="Dive deeper into the capabilities and advanced feature of the Angular DI system in the following pages:" />
      <item value="`@Inject()` and `@Optional()` are _parameter decorators_. They alter the way the DI framework provides a dependency, by annotating the dependency parameter on the constructor of the class that requires the dependency." />
      <item value="When a component or service declares a dependency, the class constructor takes that dependency as a parameter. You can tell Angular that the dependency is optional by annotating the constructor parameter with `@Optional()`." />
      <item value="`HeroService` *requires* a logger, but what if it could get by without one?" />
      <item value="The behavior is similar when you write a constructor that requires an injected class-based dependency.&#10;When you define a constructor parameter with the `HeroService` class type, Angular knows to inject the service associated with that `HeroService` class token:" />
      <item value="In simple examples, the dependency value is an *instance*, and&#10;the class *type* serves as its own lookup key.&#10;Here you get a `HeroService` directly from the injector by supplying the `HeroService` type as the token:" />
      <item value="The decorator requirement is imposed by TypeScript. TypeScript normally discards parameter type information when it [transpiles](guide/glossary#transpile) the code to JavaScript. TypeScript preserves this information if the class has a decorator and the `emitDecoratorMetadata` compiler option is set `true` in TypeScript's `tsconfig.json` configuration file. The CLI configures `tsconfig.json` with `emitDecoratorMetadata: true`." />
      <item value="When Angular creates a class whose constructor has parameters, it looks for type and injection metadata about those parameters so that it can inject the correct service.&#10;If Angular can't find that parameter information, it throws an error. Angular can only find the parameter information _if the class has a decorator of some kind_.&#10;The `@Injectable()` decorator is the standard decorator for service classes." />
      <item value="Notice that the `Logger` service also has the `@Injectable()` decorator, even though it might not need its own dependencies. In fact, the `@Injectable()` decorator is **required for all services**." />
      <item value="Here is the revised `HeroService` that injects `Logger`, side by side with the previous service for comparison." />
      <item value="Service can have their own dependencies. `HeroService` is very simple and doesn't have any dependencies of its own. Suppose, however, that you want it to report its activities through a logging service. You can apply the same *constructor injection* pattern, adding a constructor that takes a `Logger` parameter." />
      <item value="Designing a class with dependency injection makes the class easier to test.&#10;Listing dependencies as constructor parameters may be all you need to test application parts effectively." />
      <item value="For example, Angular can inject `HeroListComponent` with both the `HeroService` provided in `HeroComponent` and the `UserService` provided in `AppModule`." />
      <item value="Thanks to [injector inheritance](guide/hierarchical-dependency-injection), you can still inject application-wide services into these components. A component's injector is a child of its parent component's injector, and a descendent of its parent's parent's injector, and so on all the way back to the application's _root_ injector. Angular can inject a service provided by any injector in that lineage." />
      <item value="Child modules and component injectors are independent of each other, and create their own separate instances of the provided services. When Angular destroys an NgModule or component instance, it also destroys that injector and that injector's service instances." />
      <item value="Angular DI has a [hierarchical injection system](guide/hierarchical-dependency-injection), which means that nested injectors can create their own service instances. Angular regularly creates nested injectors. Whenever Angular creates a new instance of a component that has `providers` specified in `@Component()`, it also creates a new _child injector_ for that instance.&#10;Similarly, when a new NgModule is lazy-loaded at run time, Angular can create an injector for it with its own providers." />
      <item value="There is only one root injector for an app. Providing `UserService` at the `root` or `AppModule` level means it is registered with the root injector. There is just one `UserService` instance in the entire app and every class that injects `UserService` gets this service instance _unless_ you configure another provider with a _child injector_." />
      <item value="`HeroService` must provided in some parent injector. The code in `HeroListComponent` doesn't depend on where `HeroService` comes from. If you decided to provide `HeroService` in `AppModule`, `HeroListComponent` wouldn't change." />
      <item value="`HeroService` must provided in some parent injector. The code in `HeroListComponent` doesn't depend on where `HeroService` comes from.&#10;If you decided to provide `HeroService` in `AppModule`, `HeroListComponent` wouldn't change." />
      <item value="Of course, `HeroListComponent` should do something with the injected `HeroService`.&#10;Here's the revised component, making use of the injected service, side-by-side with the previous version for comparison." />
      <item value="You can tell Angular to inject a dependency in a component's constructor by specifying a **constructor parameter with the dependency type**. Here's the `HeroListComponent` constructor, asking for the `HeroService` to be injected." />
      <item value="In order for `HeroListComponent` to get heroes from `HeroService`, it needs to ask for `HeroService` to be injected, rather than creating it's own `HeroService` instance with `new`." />
      <item value="Components are directives, and the `providers` option is inherited from `@Directive()`. You can also configure providers for directives and pipes at the same level as the component." />
      <item value="The `@Injectable()` decorator has the `providedIn` metadata option, where you can specify the provider of the decorated service class with the `root` injector, or with the injector for a specific NgModule." />
      <item value="Injectors are inherited, which means that if a given injector can't resolve a dependency, it asks the parent injector to resolve it. A component can get services from its own injector, from the injectors of its component ancestors, from the injector of its parent NgModule, or from the `root` injector." />
      <item value="A provider can be the service class itself, so that the injector can use `new` to create an instance.&#10;You might also define more than one class to provide the same service in different ways, and configure different injectors with different providers." />
      <item value="The injector is responsible for creating service instances and injecting them into classes like `HeroListComponent`. You rarely create an Angular injector yourself. Angular creates injectors for you as it executes the app, starting with the _root injector_ that it creates during the [bootstrap process](guide/bootstrapping)." />
      <item value="The class we have created provides a service. The `@Injectable()` decorator marks it as a service that can be injected, but Angular can't actually inject it anywhere until you configure an Angular [dependency injector](guide/glossary#injector) with a [provider](guide/glossary#provider) of that service." />
      <item value="The `@Injectable()` is an essential ingredient in every Angular service definition. The rest of the class has been written to expose a `getHeroes` method that returns the same mock data as before. (A real app would probably get its data asynchronously from a remote server, but we'll ignore that to focus on the mechanics of injecting the service.)" />
      <item value="It is possible to define the component first with the help of the `forwardRef()` method as explained in this [blog post](http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html)." />
      <item value="If you do combine a component and service in the same file, it is important to define the service first, and then the component. If you define the component before the service, you get a run-time null reference error." />
      <item value="Having multiple classes in the same file can be confusing. We generally recommend that you define components and services in separate files." />
      <item value="The DI framework lets you supply data to a component from an injectable _service_ class, defined in its own file. To demonstrate, we'll create an injectable service class that provides a list of heroes, and register that class as a provider of that service." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="400" />
        <entry key="ENGLISH" value="402" />
        <entry key="ROMANIAN" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
</application>