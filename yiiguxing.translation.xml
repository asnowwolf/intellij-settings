<application>
  <component name="AppStorage">
    <histories>
      <item value="Defines the logic for the app's root component, named `AppComponent`. The view associated with this root component becomes the root of the [view hierarchy](guide/glossary#view-hierarchy) as you add components and services to your app." />
      <item value="Inside the `src/` folder, the `app/` folder contains your app's logic and data. Angular components, templates, and styles go here. An `assets/` subfolder contains images and anything else your app needs. Files at the top level of `src/` support testing and running your app." />
      <item value="An `e2e/` subfolder contains configuration and source files for a set of end-to-end tests that correspond to the initial app. Workspace-wide `node_modules` dependencies are visible to this project." />
      <item value="An `e2e/` subfolder contains configuration and source files for a set of end-to-end tests that correspond to the initial app.&#10;Workspace-wide `node_modules` dependencies are visible to this project." />
      <item value="&lt;t&gt;The main entry point for your app. Compiles the application with the [JIT compiler](https://angular.io/guide/glossary#jit) and bootstraps the application's root module (AppModule) to run in the browser. You can also use the [AOT compiler](https://angular.io/guide/aot-compiler) without changing any code by appending the `--aot` flag to the CLI `build` and `serve` commands. &lt;/t&gt;&lt;t&gt;&lt;/t&gt;" />
      <item value="Configures sharing of target browsers and Node.js versions among various front-end tools." />
      <item value="Besides using the CLI on the command line, You can also use an interactive development environment like [Angular Console](https://angular.console.com), or manipulate files directly in the app's source folder and configuration files." />
      <item value="&lt;t&gt;Provides version information for all packages installed into `node_modules` by the npm client. See [npm documentation](https://docs.npmjs.com/files/package-lock.json) for details. If you use the yarn client, this file will be [yarn.lock](https://yarnpkg.com/lang/en/docs/yarn-lock/) instead. &lt;/t&gt;&lt;t&gt;&lt;/t&gt;" />
      <item value="Lists package dependencies. See [npm documentation](https://docs.npmjs.com/files/package.json) for the specific format and contents of this file." />
      <item value="CLI configuration for all projects in the workspace, including configuration options for build, serve, and test tools that the CLI uses, such as [Karma](https://karma-runner.github.io/) and [Protractor](http://www.protractortest.org/)." />
      <item value="Specifies intentionally untracked files that [Git](https://git-scm.com/) should ignore." />
      <item value="The Angular CLI command `ng new &lt;project_name&gt;` gets you started." />
      <item value="If you work behind a corporate proxy, the cannot directly proxy calls to any URL outside your local network. In this case, you can configure the backend proxy to redirect calls through your corporate proxy using an agent:" />
      <item value="### Bypass the proxy" />
      <item value="Set the proxy configuration file to `proxy.conf.js` (instead of `proxy.conf.json`), and specify configuration files as in the following example." />
      <item value="### Proxy multiple entries" />
      <item value="You can use the [proxying support](https://webpack.js.org/configuration/dev-server/#devserver-proxy) in the `webpack` dev server to divert certain URLs to a backend server, by passing a file to the `--proxy-config` build option.&#10;For example, to divert all calls for `http://localhost:4200/api` to a server running on `http://localhost:3000/api`, take the following steps." />
      <item value="If you want to produce a progressive web app and are using [Lighthouse](https://developers.google.com/web/tools/lighthouse/) to grade the project, add the following browserslist entry to your `package.json` file, in order to eliminate the [old flexbox](https://developers.google.com/web/tools/lighthouse/audits/old-flexbox) prefixes:" />
      <item value="Internally, Autoprefixer relies on a library called [Browserslist](https://github.com/browserslist/browserslist) to figure out which browsers to support with prefixing. Browserlist looks for configuration options in a `browserlist` property of the package configuration file, or in a configuration file named `.browserslistrc`. Autoprefixer looks for the Browserlist configuration when it prefixes your CSS." />
      <item value="Warns when the size reaches this threshold percentage of the baseline." />
      <item value="Reports an error when the size exceeds this threshold percentage of the baseline." />
      <item value="Warns when a size exceeds this threshold percentage of the baseline." />
      <item value="## Configure size budgets" />
      <item value="You can also configure the `serve` command to use the targeted build configuration if you add it to the &quot;serve:configurations&quot; section of `angular.json`:" />
      <item value="This means that when you build your production configuration (using `ng build --prod` or `ng build --configuration=production`), the `src/environments/environment.ts` file is replaced with the target-specific version of the file, `src/environments/environment.prod.ts`." />
      <item value="The main CLI configuration file, `angular.json`, contains a `fileReplacements` section in the configuration for each build target, which allows you to replace any file with a target-specific version of that file. This is useful for including target-specific code or variables in a build that targets a specific environment, such as production or staging." />
      <item value="This ensures that the build and serve commands can find the configurations for specific build targets." />
      <item value="To use the environment configurations you have defined, your components must import the original environments file:" />
      <item value="This page discusses build-specific configuration options for Angular projects." />
      <item value="You can add target-specific configuration files, such as `environment.prod.ts`. The following sets content sets default values for the production build target:" />
      <item value="The `build` command uses this as the build target when no environment is specified. You can add further variables, either as additional properties on the environment object, or as separate objects. For example, the following adds a default for a variable to the default environment:" />
      <item value="The following figure shows how a project has multiple build targets, which can be executed using the named configurations that you define." />
      <item value="You develop apps in the context of an Angular [workspace](guide/glossary#workspace). A workspace contains the files for one or more [projects](guide/glossary#project). A project is the set of files that comprise a standalone app, a library, or a set of end-to-end (e2e) tests." />
      <item value="&lt;p&gt;List of components not referenced in any reachable template, for example dynamically created from code.&lt;/p&gt;" />
      <item value="Choosing a strategy begins with understanding the strengths and weaknesses of the options presented. Low-level API and form model access, predictability, mutability, straightforward validation and testing strategies, and scalability are all important consideration in choosing the infrastructure you use when building your forms in Angular. Template-driven forms are similar to patterns in AngularJS, but they have limitations given the criteria of many modern, large-scale Angular apps. Reactive forms integrate with reactive patterns already present in other areas of the Angular architecture, and complement those requirements well. Those limitations are alleviated with reactive forms." />
      <item value="## Final Thoughts" />
      <item value="**Template-driven** forms focus on simple scenarios, are not as reusable, abstract away the low-level APIs and access to the form model is provided asynchronously. The abstraction with template-driven forms surfaces in testing also, where testing reactive forms requires less setup and no dependence on the change detection cycle when updating and validating the form and data models during testing." />
      <item value="**Reactive forms** make creating large scale forms easier by providing access to low-level APIs and synchronous access to the form model." />
      <item value="If forms are a central part of your application, scalability is very important. Being able to reuse form models across components is critical." />
      <item value="With template-driven forms, the **favorite color property** is always modified to its new value." />
      <item value="With reactive forms, the **`FormControl` instance** always returns a new value when the control's value is updated." />
      <item value="The difference is demonstrated in the examples above using the **favorite color** input element." />
      <item value="**Template-driven** forms rely on mutability with two-way data binding to update the data model in the component as changes are made in the template. Because there are no unique changes to track on the data model when using two-way data binding, change detection is less efficient at determining when updates are required." />
      <item value="**Reactive forms** keep the data model pure by providing it as an immutable data structure. Each time a change is triggered on the data model, the `FormControl` instance returns a new data model rather than updating the data model directly. This gives you the ability track unique changes to the data model through the control's observable. This allows change detection to be more efficient because it only needs to update on unique changes. It also follows reactive patterns that integrate with observable operators to transform data." />
      <item value="How changes are tracked plays a role in the efficiency of your application." />
      <item value="Set the new value for the input is set to *Red*, and dispatch the &quot;input&quot; event on the form input element." />
      <item value="Query the view for the form input element, and create a custom &quot;input&quot; event for the test." />
      <item value="The following tests use the favorite color components mentioned earlier to verify the view to model and model to view data flows for a template-driven form." />
      <item value="Writing tests with template-driven forms requires more detailed knowledge of the change detection process and how directives run on each cycle to ensure elements are queried, tested, or changed at the correct time." />
      <item value="Assert that the new value set on the control matches the value in the input." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="603" />
        <entry key="ENGLISH" value="608" />
        <entry key="ROMANIAN" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
</application>