<application>
  <component name="AppStorage">
    <histories>
      <item value="This bare minimum `NgModule` imports `BrowserModule`, the module every Angular browser-based app must have. It also defines an empty `ngDoBootstrap()` method, to prevent the {@link Compiler Compiler} from returning errors. This is necessary because the module will not have a `bootstrap` declaration on its `NgModule` decorator." />
      <item value="In order to start using any `upgrade/static` APIs, you still need to load the Angular framework as you would in a normal Angular app. You can see how this can be done with SystemJS by following the instructions in the [Setup](guide/setup) guide, selectively copying code from the [QuickStart github repository](https://github.com/angular/quickstart)." />
      <item value="As you might have guessed, you don't need to change anything in the way you bootstrap your existing AngularJS app. Unlike `UpgradeModule`&amp;mdash;which requires some extra steps&amp;mdash; `downgradeModule()` is able to take care of bootstrapping the Angular module, as long as you provide the recipe." />
      <item value="You use Angular for a feature that is not critical for the initial rendering of the app and you can afford a small delay in favor of better initial load performance." />
      <item value="You use Angular for features that are only visible to specific types of users; for example, logged-in users, administrators, or VIP members. You don't need to load Angular until a user is authenticated." />
      <item value="A few examples are:" />
      <item value="You could go a step further and not even download the code for the Angular part of the app to the user's browser until it is needed. This is especially useful when you use Angular on parts of the hybrid app that are not necessary for the initial rendering or that the user doesn't reach." />
      <item value="Another key difference between `downgradeModule()` and `UpgradeModule` is that the latter requires you to instantiate both the AngularJS and Angular modules up-front. This means that you have to pay the cost of instantiating the Angular part of the app, even if you don't use any Angular assets until later. `downgradeModule()` is again less aggressive. It will only instantiate the Angular part when it is required for the first time; that is, as soon as it needs to create a downgraded component." />
      <item value="#### Instantiating the Angular module on-demand" />
      <item value="Using an `NgModuleFactory` requires less boilerplate and is a good default option as it supports AOT out-of-the-box. Using a custom function requires slightly more code, but gives you greater flexibility." />
      <item value="Alternatively, you can pass a plain function, which is expected to return a promise resolving to an {@link NgModuleRef NgModuleRef} (i.e. an instance of your Angular module). The function is called with an array of extra {@link StaticProvider Providers} that are expected to be available on the returned `NgModuleRef`'s {@link Injector Injector}. For example, if you are using {@link platformBrowser platformBrowser} or {@link platformBrowserDynamic platformBrowserDynamic}, you can pass the `extraProviders` array to them:" />
      <item value="When you pass an `NgModuleFactory`, `downgradeModule()` uses it to instantiate the module using {@link platformBrowser platformBrowser}'s {@link PlatformRef#bootstrapModuleFactory bootstrapModuleFactory()}, which is compatible with ahead-of-time (AOT) compilation. AOT compilation helps make your apps load faster. For more about AOT and how to create an `NgModuleFactory`, see the [Ahead-of-Time Compilation](guide/aot-compiler) guide." />
      <item value="As mentioned earlier, `downgradeModule()` needs to know how to instantiate the Angular module. It needs a recipe. You define that recipe by providing a factory function that can create an instance of the Angular module. `downgradeModule()` accepts two types of factory functions:" />
      <item value="There are a few things to note, though:" />
      <item value="An important part of inter-linking dependencies is linking the two main modules together. This is where `downgradeModule()` comes in. Use it to create an AngularJS module&amp;mdash;one that you can use as a dependency in your main AngularJS module&amp;mdash;that will bootstrap your main Angular module and kick off the Angular part of the hybrid app. In a sense, it &quot;downgrades&quot; an Angular module to an AngularJS module." />
      <item value="For the most part, you specify the modules in the same way you would for a regular app. Then, you use the `upgrade/static` helpers to let the two frameworks know about assets they can use from each other. This is known as &quot;upgrading&quot; and &quot;downgrading&quot;." />
      <item value="Their details are quite different in architecture and implementation. In AngularJS, you create a module by specifying its name and dependencies with [angular.module()](https://docs.angularjs.org/api/ng/function/angular.module). Then you can add assets using its various methods. In Angular, you create a class adorned with an {@link NgModule NgModule} decorator that describes assets in metadata." />
      <item value="Both AngularJS and Angular have their own concept of modules to help organize an app into cohesive blocks of functionality." />
      <item value="In many cases, a few extra change detection runs may not matter much. However, on larger or change-detection-heavy apps they can have a noticeable impact. By giving you more fine-grained control over the change detection propagation, `downgradeModule()` allows you to achieve better performance for your hybrid apps." />
      <item value="If you want a particular piece of code to trigger change detection in the AngularJS part of the app, you need to wrap it in [scope.$apply()](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply). Similarly, for triggering change detection in Angular you would use {@link NgZone#run ngZone.run()}." />
      <item value="In most cases, though, the changes made locally in a particular component are of no interest to the rest of the app. For example, if the user clicks a button that submits a form, the component usually handles the result of this action. That being said, there _are_ cases where you want to propagate changes to some other part of the app that may be controlled by the other framework. In such cases, you are responsible for notifying the interested parties by manually triggering change detection." />
      <item value="`downgradeModule()`, on the other side, avoids explicitly triggering change detection unless it knows the other part of the app is interested in the changes. For example, if a downgraded component defines an `@Input()`, chances are that the app needs to be aware when that value changes. Thus, `downgradeComponent()` automatically triggers change detection on that component." />
      <item value="The [Change Detection](guide/upgrade#change-detection) section of [Upgrading from AngularJS](guide/upgrade) only applies to apps that use `UpgradeModule`. Though you handle change detection differently with `downgradeModule()`, which is the focus of this guide, reading the [Change Detection](guide/upgrade#change-detection) section provides helpful context for what follows." />
      <item value="Regardless of whether you choose `downgradeModule()` or `UpgradeModule`, the basic principles of upgrading, the mental model behind hybrid apps, and how you use the {@link upgrade/static upgrade/static} utilities remain the same. For more information, see the [How `ngUpgrade` Works](guide/upgrade#how-ngupgrade-works) section of [Upgrading from AngularJS](guide/upgrade)." />
      <item value="With the `ngUpgrade` library in Angular you can upgrade an existing AngularJS app incrementally by building a hybrid app where you can run both frameworks side-by-side. In these hybrid apps you can mix and match AngularJS and Angular components and services and have them interoperate seamlessly. That means you don't have to do the upgrade work all at once as there is a natural coexistence between the two frameworks during the transition period." />
      <item value="Before discussing how you can use `downgradeModule()` to create hybrid apps, there are things that you can do to ease the upgrade process even before you begin upgrading. Because the steps are the same regardless of how you upgrade, refer to the [Preparation](guide/upgrade#preparation) section of [Upgrading from AngularJS](guide/upgrade)." />
      <item value="This guide describes some of the built-in tools for efficiently migrating AngularJS projects over to the Angular platform, one piece at a time. It is very similar to [Upgrading from AngularJS](guide/upgrade) with the exception that this one uses the {@link downgradeModule downgradeModule()} helper function instead of the {@link UpgradeModule UpgradeModule} class. This affects how the app is bootstrapped and how change detection is propagated between the two frameworks. It allows you to upgrade incrementally while improving the speed of your hybrid apps and leveraging the latest of Angular in AngularJS apps early in the process of upgrading." />
      <item value="Here's a revised version that defaults to `parent` but also accepts an optional second parameter for a different parent class interface." />
      <item value="You can extract that logic into a helper function like the following." />
      <item value="Writing variations of the same parent *alias provider* gets old quickly, especially this awful mouthful with a [*forwardRef*](guide/dependency-injection-in-action#forwardref)." />
      <item value="`AlexComponent` *should* implement `Parent` as a matter of proper style.&#10;It doesn't in this example *only* to demonstrate that the code will compile and run without the interface." />
      <item value="Doing so adds clarity to the code. But it's not technically necessary.&#10;Although `AlexComponent` has a `name` property, as required by its `Base` class, its class signature doesn't mention `Parent`." />
      <item value="A component that could serve as a parent *should* implement the class interface as the `AliceComponent` does." />
      <item value="You [learned earlier](guide/dependency-injection-in-action#class-interface) that a class interface is an abstract class used as an interface rather than as a base class." />
      <item value="It tells the injector to start its search for a `Parent` dependency in a component *above* itself, which *is* what parent means." />
      <item value="`@SkipSelf` is essential for two reasons:" />
      <item value="It's identical to *Carol*'s constructor except for the additional `@SkipSelf` decorator." />
      <item value="*Barry*'s `providers` array looks just like [*Alex*'s](#alex-providers).&#10;If you're going to keep writing [*alias providers*](guide/dependency-injection-in-action#useexisting) like this you should create a [helper function](#provideparent)." />
      <item value="*Barry* is the problem. He needs to reach his parent, *Alice*, and also be a parent to *Carol*.&#10;That means he must both *inject* the `Parent` class interface to get *Alice* and *provide* a `Parent` to satisfy *Carol*." />
      <item value="Imagine one branch of a component hierarchy: *Alice* -&gt; *Barry* -&gt; *Carol*.&#10;Both *Alice* and *Barry* implement the `Parent' class interface." />
      <item value="### Find a parent in a tree with _@SkipSelf()_" />
      <item value="[Parent](#parent-token) is the provider's class interface token.&#10;The [*forwardRef*](guide/dependency-injection-in-action#forwardref) breaks the circular reference you just created by having the `AlexComponent` refer to itself." />
      <item value="Write an [*alias provider*](guide/dependency-injection-in-action#useexisting)&amp;mdash;a `provide` object literal with a `useExisting` definition&amp;mdash;that creates an *alternative* way to inject the same component instance and add that provider to the `providers` array of the `@Component()` metadata for the `AlexComponent`." />
      <item value="The parent must cooperate by providing an *alias* to itself in the name of a class interface token." />
      <item value="Unfortunately, this doesn't work.&#10;The &lt;live-example name=&quot;dependency-injection-in-action&quot;&gt;&lt;/live-example&gt; confirms that the `alex` parameter is null. *You cannot inject a parent by its base class.*" />
      <item value="The sample's `CraigComponent` explores this question. [Looking back](#alex), you see that the `Alex` component *extends* (*inherits*) from a class named `Base`." />
      <item value="This isn't necessarily good design.&#10;This example is examining *whether a component can&#10;inject its parent via the parent's base class*." />
      <item value="Looking for components that implement an interface would be better. That's not possible because TypeScript interfaces disappear from the transpiled JavaScript, which doesn't support interfaces. There's no artifact to look for." />
      <item value="The app probably defines more than a dozen financial instrument components.&#10;If you're lucky, they all implement the same base class whose API your `NewsComponent` understands." />
      <item value="A re-usable component might be a child of multiple components. Imagine a component for rendering breaking news about a financial instrument. For business reasons, this news component makes frequent calls directly into its parent instrument as changing market data streams by." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="543" />
        <entry key="ENGLISH" value="547" />
        <entry key="ROMANIAN" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
</application>