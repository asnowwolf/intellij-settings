<application>
  <component name="AppStorage">
    <histories>
      <item value="Angular, the Angular CLI, and Angular apps depend on features and functionality provided by libraries that are available as [npm packages](https://docs.npmjs.com/getting-started/what-is-npm). To download and install npm packages, you must have an npm package manager." />
      <item value="This guide takes less than 30 minutes to complete. At the end of this guide&amp;mdash;as part of final code review&amp;mdash;there is a link to download a copy of the final application code. (If you don't execute the commands in this guide, you can still download the final application code.)" />
      <item value="This guide shows you how to build and run a simple Angular app. You'll use the [Angular CLI tool](cli &quot;CLI command reference&quot;) to accelerate development, while adhering to the [Style Guide](guide/styleguide &quot;Angular style guide&quot;) recommendations that benefit _every_ Angular project." />
      <item value="Welcome to Angular! Angular helps you build modern applications for the web, mobile, or desktop." />
      <item value="It also creates the following workspace and starter project files:" />
      <item value="The Angular CLI installs the necessary Angular `npm` packages and other dependencies. This can take a few minutes." />
      <item value="The `ng new` command prompts you for information about features to include in the initial app project. Accept the defaults by pressing the Enter or Return key." />
      <item value="Ensure that you are not already in an Angular workspace folder. For example, if you have previously created the Getting Started workspace, change to the parent of that folder." />
      <item value="You develop apps in the context of an Angular [workspace](guide/glossary#workspace). A workspace contains the files for one or more [projects](guide/glossary#project). A project is the set of files that comprise an app, a library, or end-to-end (e2e) tests. For this tutorial, you will create a new workspace." />
      <item value="**Note:**: You do not need to complete the entire Getting Started. After you complete the above two sections of Getting Started, your environment is set up. Continue below to create the Tour of Heroes workspace and an initial app project." />
      <item value="  [Prerequisites](guide/quickstart#prerequisites)&#10;" />
      <item value="To set up your development environment, follow these instructions in [Getting Started](guide/quickstart):" />
      <item value="You begin by creating an initial application using the Angular CLI. Throughout this tutorial, youâ€™ll modify and extend that starter application to create the Tour of Heroes app." />
      <item value="Another reason to re-provide a service at another level is to substitute a _ more specialized _ implementation of that service, deeper in the component tree." />
      <item value="Another reason to re-provide a service at another level is to substitute a _more specialized_ implementation of that service, deeper in the component tree." />
      <item value="If you provide `VillainsService` in the root `AppModule` (where you registered the `HeroesService`), that would make the `VillainsService` available everywhere in the application, including the _Hero_ workflows. If you later modified the `VillainsService`, you could break something in a hero component somewhere. Providing the service in the root `AppModule` creates that risk." />
      <item value="For example, the guide sample includes a `VillainsListComponent` that displays a list of villains.&#10;It gets those villains from a `VillainsService`." />
      <item value="If you only register providers with the root injector at the top level (typically the root `AppModule`), the tree of injectors appears to be flat.&#10;All requests bubble up to the root injector, whether you configured it with the `bootstrapModule` method, or registered all providers with `root` in their own services." />
      <item value="See an [example](guide/dependency-injection-in-action#qualify-dependency-lookup) of using `@Host` together with `@Optional`, another parameter decorator that lets you handle the null case if no provider is found." />
      <item value="You can cap the bubbling by adding the `@Host()` parameter decorator on the dependant-service parameter in a component's constructor. The hunt for providers stops at the injector for the host element of the component." />
      <item value="If you have registered a provider for the same DI token at different levels, the first one Angular encounters is the one it uses to provide the dependency. If, for example, a provider is registered locally in the component that needs a service, Angular doesn't look for another provider of the same service." />
      <item value="Components are a special type of directive, and the `providers` property of `@Component()` is inherited from `@Directive()`. Directives can also have dependencies, and you can configure providers in their `@Directive()` metadata. When you configure a provider for a component or directive using the `providers` property, that provider belongs to the injector for the anchor DOM element. Components and directives on the same element share an injector." />
      <item value="The following example is a revised `HeroesComponent` that specifies `HeroService` in its `providers` array. `HeroService` can provide heroes to instances of this component, or to any child component instances." />
      <item value="Here is an example of the case where the component router configuration includes a non-default [location strategy](guide/router#location-strategy) by listing its provider in the `providers` list of the `AppModule`." />
      <item value="You generally don't need to specify `AppModule` with `providedIn`, because the app's `root` injector is the `AppModule` injector. However, if you configure a app-wide provider in the`@NgModule()` metadata for `AppModule`, it overrides one configured for `root` in the `@Injectable()` metadata. You can do this to configure a non-default provider of a service that is shared with multiple apps." />
      <item value="You can configure a provider at the module level using the `providedIn` metadata option for a non-root NgModule, in order to limit the scope of the provider to that module.&#10;This is the equivalent of specifying the non-root module in the `@Injectable()` metadata, except that the service provided this way is not tree-shakable." />
      <item value="This is generally no different from configuring the injector of the NgModule itself, except that the service is tree-shakable if the NgModule doesn't use it. It can be useful for a library that offers a particular service that some components *might* want to inject optionally, and leave it up to the app whether to provide the service." />
      <item value="Providing a service with the app's root injector is a typical case, and the CLI sets up this kind of a provider automatically for you when generating a new service. However, you might not always want to provide your service at the root level. You might, for instance, want users to explicitly opt-in to using the service." />
      <item value="This configuration tells Angular that the app's root injector is responsible for creating an instance of `HeroService` by invoking its constructor, and for making that instance available across the application." />
      <item value="The `@Injectable()` decorator identifies every service class. The `providedIn` metadata option for a service class configures a specific injector (typically `root`) to use the decorated class as a provider of the service. When an injectable class provides its own service to the `root` injector, the service is available anywhere the class is imported." />
      <item value="In our sample app, `HeroComponent` is created when the application starts and is never destroyed, so the `HeroService` instance created for `HeroComponent` lives for the life of the app. If you want to restrict `HeroService` access to `HeroComponent` and its nested `HeroListComponent`, provide `HeroService` at the component level, in `HeroComponent` metadata." />
      <item value="Use the `@NgModule()` `provides` option if a module is [lazy loaded](guide/lazy-loading-ngmodules). The module's own injector is configured with the provider when that module is loaded, and Angular can inject the corresponding services in any class it creates in that module. If you use the `@Injectable()` option `providedIn: MyLazyloadModule`, the provider could be shaken out at compile time, if it is not used anywhere else in the app." />
      <item value="Learn more about dependency resolution through the injector hierarchy: [What you always wanted to know about Angular Dependency Injection tree](https://blog.angularindepth.com/angular-dependency-injection-and-tree-shakeable-tokens-4588a8f70d5d)" />
      <item value="You're likely to inject `UserService` in many places throughout the app and will want to inject the same service instance every time. Providing `UserService` through the `root` injector is a good choice, and is the default that the [Angular CLI](cli) uses when you generate a service for your app." />
      <item value="You can configure providers for different injectors in the injector hierarchy. An internal platform-level injector is shared by all running apps. The `AppModule` injector is the root of an app-wide injector hierarchy, and within an NgModule, directive-level injectors follow the structure of the component hierarchy." />
      <item value="The `ng serve` command builds, watches, and serves the application from local memory, using a local development server. When you have deployed your app to another server, however, you might still want to serve the app so that you can continue to see changes that you make in it. You can do this by adding the `--watch` option to the `ng build` command." />
      <item value="The `ng serve` command builds, watches, and serves the application from local memory, using a local development server.&#10;When you have deployed your app to another server, however, you might still want to serve the app so that you can continue to see changes that you make in it. You can do this by adding the `--watch` option to the `ng build` command." />
      <item value="When you are designing and developing applications, you typically use `ng serve` to build your app for fast, local, iterative development. When you are ready to deploy, however, you must use the `ng build` command to build the app and deploy the build artifacts elsewhere." />
      <item value="## Building and serving for deployment" />
      <item value="But on the shared or production server, you might serve the app from a subfolder.&#10;For example, when the URL to load the app is something like `http://www.mysite.com/my/app/`,&#10;the subfolder is `my/app/` and you should add `&lt;base href=&quot;/my/app/&quot;&gt;` to the server version of the `index.html`." />
      <item value="In development, you typically start the server in the folder that holds `index.html`.&#10;That's the root folder and you'd add `&lt;base href=&quot;/&quot;&gt;` near the top of `index.html` because `/` is the root of the app." />
      <item value="The HTML [_&amp;lt;base href=&quot;...&quot;/&amp;gt;_](/guide/router) specifies a base path for resolving relative URLs to assets such as images, scripts, and style sheets. For example, given the `&lt;base href=&quot;/my/app/&quot;&gt;`, the browser resolves a URL such as `some/place/foo.jpg` into a server request for `my/app/some/place/foo.jpg`. During navigation, the Angular router uses the _base href_ as the base path to component, template, and module files." />
      <item value="Run the explorer to generate a graphical representation of one of the bundles.&#10;The following example displays the graph for the _main_ bundle." />
      <item value="### Inspect the bundles" />
      <item value="The [WebPageTest](https://www.webpagetest.org/) tool is another good choice&#10;that can also help verify that your deployment was successful." />
      <item value="You can make better decisions about what to optimize and how when you have a clear and accurate understanding of what's making the application slow. The cause may not be what you think it is. You can waste a lot of time and money optimizing something that has no tangible benefit or even makes the app slower. You should measure the app's actual behavior when running in the environments that are important to you. The &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/network-performance/understanding-resource-timing&quot; title=&quot;Chrome DevTools Network Performance&quot;&gt; Chrome DevTools Network Performance page&lt;/a&gt; is a good place to start learning about measuring performance." />
      <item value="### Measure performance" />
      <item value="The bundling configuration must take lazy loading into consideration.&#10;Because lazy-loaded modules aren't imported in JavaScript, bundlers exclude them by default.&#10;Bundlers don't know about the router configuration and can't create separate bundles for lazy-loaded modules. You would have to create these bundles manually." />
      <item value="If you mean to lazy-load a module, be careful not import it in a file that's eagerly loaded when the app starts (such as the root `AppModule`). If you do that, the module will be loaded immediately." />
      <item value="#### Don't eagerly import something from a lazy-loaded module" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="420" />
        <entry key="ENGLISH" value="423" />
        <entry key="ROMANIAN" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
</application>