<application>
  <component name="AppStorage">
    <histories>
      <item value="In our case we'll just focus the first `&lt;input&gt;` if the user isn't about to click an `&lt;input&gt;` anyways." />
      <item value="This property allows us to specify a unique string for the type of control in form field. The `&lt;mat-form-field&gt;` will add an additional class based on this type that can be used to easily apply special styles to a `&lt;mat-form-field&gt;` that contains a specific type of control. In this example we'll use `my-tel-input` as our control type which will result in the form field adding the class `mat-form-field-my-tel-input`." />
      <item value="This property is used to indicate whether the label should be in the floating position. We'll use the same logic as `matInput` and float the placeholder when the input is focused or non-empty. Since the placeholder will be overlapping our control when when it's not floating, we should hide the `–` characters when it's not floating." />
      <item value="This property is used to indicate whether the label should be in the floating position. We'll&#10;use the same logic as `matInput` and float the placeholder when the input is focused or non-empty.&#10;Since the placeholder will be overlapping our control when when it's not floating, we should hide the `–` characters when it's not floating." />
      <item value="id" />
      <item value="complete" />
      <item value="Because the `&lt;mat-form-field&gt;` uses the `OnPush` change detection strategy, we need to let it know when something happens in the form field control that may require the form field to run change detection. We do this via the `stateChanges` property. So far the only thing the form field needs to know about is when the value changes. We'll need to emit on the stateChanges stream when that happens, and as we continue flushing out these properties we'll likely find more places we need to emit. We should also make sure to complete `stateChanges` when our component is destroyed." />
      <item value="robust" />
      <item value="It is possible to create custom form field controls that can be used inside `&lt;mat-form-field&gt;`. This can be useful if you need to create a component that shares a lot of common behavior with a form field, but adds some additional logic." />
      <item value="Creating a custom form field control" />
      <item value="jittery" />
      <item value="Also, sticky positioning in Edge will appear shaky for special cases. For example, if the scrolling container has a complex box shadow and has sibling elements, the stuck cells will appear jittery. There is currently an [open issue with Edge](https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/17514118/) to resolve this." />
      <item value="Note that on Safari mobile when using the flex-based table, a cell stuck in more than one direction will struggle to stay in the correct position as you scroll. For example, if a header row is stuck to the top and the first column is stuck, then the top-left-most cell will appear jittery as you scroll." />
      <item value="Finally, adjust the styling for the select column so that its overflow is not hidden. This allows the ripple effect to extend beyond the cell." />
      <item value="incorporate" />
      <item value="To override the default filtering behavior, a custom `filterPredicate` function can be set which takes a data object and filter string and returns true if the data object is considered a match." />
      <item value="If you are using the `MatTableDataSource`, simply provide the filter string to the `MatTableDataSource`. The data source will reduce each row data to a serialized form and will filter out the row if it does not contain the filter string. By default, the row data reducing function will concatenate all the object values and convert them to lowercase." />
      <item value="A general strategy is to add an input where users can type in a filter string and listen to this input to change what data is offered from the data source to the table." />
      <item value="Angular Material does not provide a specific component to be used for filtering the `MatTable` since there is no single common approach to adding a filter UI to table data." />
      <item value="By default, the `MatTableDataSource` sorts with the assumption that the sorted column's name matches the data property name that the column displays. For example, the following column definition is named `position`, which matches the name of the property displayed in the row cell." />
      <item value="slice" />
      <item value="To simplify the use case of having a table that can sort, paginate, and filter an array of data, the Angular Material library comes with a `MatTableDataSource` that has already implemented the logic of determining what rows should be rendered according to the current table state. To add these feature to the table, check out their respective sections below." />
      <item value="You'll notice that the table itself doesn't come out of the box with a lot of features, but expects that the table will be included in a composition of components that fills out its features." />
      <item value="The `MatTable` is focused on a single responsibility: efficiently render rows of data in a performant and accessible way." />
      <item value="For most real-world applications, providing the table a DataSource instance will be the best way to manage data. The DataSource is meant to serve a place to encapsulate any sorting, filtering, pagination, and data retrieval logic specific to the application." />
      <item value="The simplest way to provide data to your table is by passing a data array. More complex use-cases may benefit from a more flexible approach involving an Observable stream or by encapsulating your data source logic into a `DataSource` class." />
      <item value="Directionality" />
      <item value="# Angular Material bi-directionality" />
      <item value="You can use either the npm or yarn command-line tool to install packages. Use whichever is appropriate for your project in the examples below." />
      <item value="A `matTreeNodeToggle` can be added in the tree node template to expand/collapse the tree node. The toggle toggles the expand/collapse functions in `TreeControl` and is able to expand/collapse a tree node recursively by setting `[matTreeNodeToggleRecursive]` to `true`." />
      <item value="Toggle" />
      <item value="The `&lt;mat-tree&gt;` itself only deals with the rendering of a tree structure.&#10;Additional features can be built on top of the tree by adding behavior inside node templates (e.g., padding and toggle). Interactions that affect the rendered data (such as expand/collapse) should be propagated through the table's data source." />
      <item value="Nested trees are easier to work with when hierarchical relationships are visually represented in ways that would be difficult to accomplish with flat nodes." />
      <item value="variations" />
      <item value="In a flat tree, the hierarchy is flattened; nodes are not rendered inside of each other, but instead are rendered as siblings in sequence. An instance of `TreeFlattener` is used to generate the flat list of items from hierarchical data. The &quot;level&quot; of each tree node is read through the `getLevel` method of the `TreeControl`; this level can be used to style the node such that it is indented to the appropriate level." />
      <item value="similar" />
      <item value="If a tooltip will only be shown manually via click, keypress, etc., then extra care should be taken such that the action behaves similarly for screen-reader users. One possible approach would be to use the `LiveAnnouncer` from the `cdk/a11y` package to announce the tooltip content on such an interaction." />
      <item value="Only if the use-case of the toolbar match that of role=&quot;toolbar&quot;, the user should add the role and an appropriate label via `aria-label` or `aria-labelledby`." />
      <item value="Generally, the toolbar is used as a header where `role=&quot;heading&quot;` would be appropriate." />
      <item value="The toolbar does not perform any positioning of its content. This gives the user full power to position the content as it suits their application." />
      <item value="Tab contents can be lazy loaded by declaring the body in a `ng-template` with the `matTabContent` attribute." />
      <item value="If the tab contains several complex child components or the tab's contents rely on DOM calculations during initialization, it is advised to lazy load the tab's content." />
      <item value="eagerly" />
      <item value="The `tab-nav-bar` is not tied to any particular router; it works with normal `&lt;a&gt;` elements and uses the `active` property to determine which tab is currently active. The corresponding `&lt;router-outlet&gt;` can be placed anywhere in the view." />
      <item value="While `&lt;mat-tab-group&gt;` is used to switch between views within a single route, `&lt;nav mat-tab-nav-bar&gt;` provides a tab-like UI for navigating between routes." />
      <item value="Angular Material tab set organize content into separate views where only one view can be visible at a time. Each tab's label is shown in the tab header and the active tab's label is designated with the animated ink bar. When the list of tab labels exceeds the width of the header, pagination controls appear to let the user scroll left and right across the labels." />
      <item value="Angular Material tabs organize content into separate views where only one view can be visible at a time. Each tab's label is shown in the tab header and the active tab's label is designated with the animated ink bar. When the list of tab labels exceeds the width of the header, pagination controls appear to let the user scroll left and right across the labels." />
      <item value="the content that can be expanded upon selection is given `role=&quot;tabpanel&quot;`" />
      <item value="the content that can be expanded upon selection is given&#10;`role=&quot;tabpanel&quot;`" />
      <item value="Labels used by the stepper are provided through `MatStepperIntl`. Localization of these messages can be done by providing a subclass with translated values in your application root module." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="275" />
        <entry key="ENGLISH" value="277" />
        <entry key="ROMANIAN" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
</application>