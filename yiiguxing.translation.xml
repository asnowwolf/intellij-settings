<application>
  <component name="AppStorage">
    <histories>
      <item value="The `&lt;mat-sidenav&gt;` an `&lt;mat-sidenav-content&gt;` should each be given an appropriate `role` attribute depending on the context in which they are used." />
      <item value="To react to scrolling inside the `&lt;mat-sidenav-container&gt;`, you can get a hold of the underlying `CdkScrollable` instance through the `MatSidenavContainer`." />
      <item value="By default, Material will only measure and resize the drawer container in a few key moments (on open, on window resize, on mode change) in order to avoid layout thrashing, however there are cases where this can be problematic. If your app requires for a drawer to change its width while it is open, you can use the `autosize` option to tell Material to continue measuring it. Note that you should use this option **at your own risk**, because it could cause performance issues." />
      <item value="thrashing" />
      <item value="The `over` and `push` sidenav modes show a backdrop by default, while the `side` mode does not." />
      <item value="Sidenav appears side-by-side with the main content, shrinking the main content's width to make space for the sidenav." />
      <item value="&lt;p translation-result&gt;侧边栏和主内容&lt;/p&gt;&lt;p translation-origin=&quot;off&quot;&gt;Sidenav appears side-by-side with the main content, shrinking the main content's width to make space for the sidenav.&lt;/p&gt;" />
      <item value="backdrop" />
      <item value="analogous" />
      <item value="side content" />
      <item value="alongside" />
      <item value="Angular Material provides two sets of components designed to add collapsible side content (often navigation, though it can be any content) alongside some primary content. These are the sidenav and drawer components." />
      <item value="#### Error: A MatDatepicker can only be associated with a single input" />
      <item value="IDENTICAL" />
      <item value="identical" />
      <item value="You will also want to make sure that the `MAT_DATE_FORMATS` provided in your app are formats that can be understood by your date implementation. See [_Customizing the parse and display formats_](#customizing-the-parse-and-display-formats)for more information about `MAT_DATE_FORMATS`. &lt;!-- TODO(mmalerba): Add a guide about this --&gt;" />
      <item value="accomplished" />
      <item value="By default the `MomentDateAdapter` will creates dates in your time zone specific locale. You can change the default behaviour to parse dates as UTC by providing the `MAT_MOMENT_DATE_ADAPTER_OPTIONS` and setting it to `useUtc: true`." />
      <item value="Because `DateAdapter` is a generic class, `MatDatepicker` and `MatDatepickerInput` also need to be made generic. When working with these classes (for example as a `ViewChild`) you should include the appropriate generic type that corresponds to the `DateAdapter` implementation you are using. For example:" />
      <item value="Because `DateAdapter` is a generic class," />
      <item value="*Please note: `MatNativeDateModule` is based off of the functionality available in JavaScript's native `Date` object, and is thus not suitable for many locales. One of the biggest shortcomings of the native `Date` object is the inability to set the parse format. We highly recommend using the `MomentDateAdapter` or a custom `DateAdapter` that works with the formatting/parsing library of your choice.*" />
      <item value="The datepicker was built to be date implementation agnostic. This means that it can be made to work with a variety of different date implementations. However it also means that developers need to make sure to provide the appropriate pieces for the datepicker to work with their chosen implementation. The easiest way to ensure this is just to import one of the pre-made modules:" />
      <item value="The datepicker was built to be date implementation agnostic. This means that it can be made to work" />
      <item value="agnostic" />
      <item value="By default, the `MAT_DATE_LOCALE` injection token will use the existing `LOCALE_ID` locale code from `@angular/core`. If you want to override it, you can provide a new value for the `MAT_DATE_LOCALE` token:" />
      <item value="1. The date locale." />
      <item value="#### Setting the locale code" />
      <item value="2. The date implementation that the datepicker accepts." />
      <item value="The datepicker normally opens as a popup under the input. However this is not ideal for touch devices that don't have as much screen real estate and need bigger click targets. For this reason `&lt;mat-datepicker&gt;` has a `touchUi` property that can be set to `true` in order to enable a more touch friendly UI where the calendar opens in a large dialog." />
      <item value="vice-versa" />
      <item value="Therefore" />
      <item value="However" />
      <item value="There are three properties that add date validation to the datepicker input. The first two are the `min` and `max` properties. In addition to enforcing validation on the input, these properties will disable all dates on the calendar popup before or after the respective values and prevent the user from advancing the calendar past the `month` or `year` (depending on current view) containing the `min` or `max` date." />
      <item value="Depending on the `DateAdapter` being used, the datepicker may automatically deserialize certain date formats for you as well. For example, both the `NativeDateAdapter` and `MomentDateAdapter` allow [ISO 8601](https://tools.ietf.org/html/rfc3339) strings to be passed to the datepicker and automatically converted to the proper object type. This can be convenient when binding data directly from your backend to the datepicker. However, the datepicker will not accept date strings formatted in user format such as `&quot;1/2/2017&quot;` as this is ambiguous and will mean different things depending on the locale of the browser running the code." />
      <item value="The type of values that the datepicker expects depends on the type of `DateAdapter` provided in your&#10;application. The `NativeDateAdapter`, for example, works directly with plain JavaScript `Date`&#10;objects. When using the `MomentDateAdapter`, however, the values will all be Moment.js instances.&#10;This use of the adapter pattern allows the datepicker component to work with any arbitrary date representation with a custom `DateAdapter`. See [_Choosing a date implementation_](#choosing-a-date-implementation-and-date-format-settings) for more information." />
      <item value="Notice that the emitted value does not affect the current value in the connected `&lt;input&gt;`, which is only bound to the selection made in the `month` view. So if the end user closes the calendar after choosing a year in `multi-view` mode (by pressing the `ESC` key, for example), the selected year, emitted by `yearSelected` output, will not cause any change in the value of the date in the associated `&lt;input&gt;`." />
      <item value="When a year or a month is selected in `multi-year` and `year` views respectively, the `yearSelected` and `monthSelected` outputs emit a normalized date representing the chosen year or month. By &quot;normalized&quot; we mean that the dates representing years will have their month set to January and their day set to the 1st. Dates representing months will have their day set to the 1st of the month. For example, if `&lt;mat-datepicker&gt;` is configured to work with javascript native Date objects, the `yearSelected` will emit `new Date(2017, 0, 1)` if the user selects 2017 in `multi-year` view. Similarly, `monthSelected` will emit `new Date(2017, 1, 1)` if the user selects **February** in `year` view and the current date value of the connected `&lt;input&gt;` was set to something like `new Date(2017, MM, dd)` when the calendar was opened (the month and day are irrelevant in this case)." />
      <item value="In order to facilitate easily styling the dropdown panel, `&lt;mat-select&gt;` has a `panelClass` property which can be used to apply additional CSS classes to the dropdown panel." />
      <item value="### Disabling the ripple effect" />
      <item value="The `&lt;mat-select&gt;` also supports all of the form directives from the core `FormsModule` (`NgModel`) and `ReactiveFormsModule` (`FormControl`, `FormGroup`, etc.) As with native `&lt;select&gt;`, `&lt;mat-select&gt;` also supports a `compareWith` function. (Additional information about using a custom `compareWith` function can be found in the [Angular forms documentation](https://angular.io/api/forms/SelectControlValueAccessor#caveat-option-selection))." />
      <item value="[Material Design spec](https://material.io/design/components/menus.html). It is designed to work inside of a [`&lt;mat-form-field&gt;`](https://material.angular.io/components/form-field/overview) element." />
      <item value="All radio-buttons with the same `name` comprise a set from which only one may be selected at a time." />
      <item value="Indicates that something is happening without conveying a discrete progress" />
      <item value="In &quot;query&quot; mode, the progress-bar renders as an inverted &quot;indeterminate&quot; bar. Once the response progress is available, the `mode` should be changed to determinate to convey the progress. In this mode the `value` property is ignored." />
      <item value="For situations where the user wants to indicate pre-loading (until the loading can actually be made), use the query indicator." />
      <item value="In &quot;buffer&quot; mode, `value` determines the progress of the primary bar while the `bufferValue` is used to show the additional buffering progress." />
      <item value="Operations where the user wants to indicate some activity or loading from the server, use the buffer indicator." />
      <item value="Indeterminate" />
      <item value="Operations where the percentage of the operation complete is known should use the determinate indicator." />
      <item value="indeterminate" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="193" />
        <entry key="ENGLISH" value="195" />
        <entry key="ROMANIAN" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
</application>