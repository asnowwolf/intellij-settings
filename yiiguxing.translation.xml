<application>
  <component name="AppStorage">
    <histories>
      <item value="Use the `animate()` function to define the length, delay, and easing of a transition, and to designate the style function for defining styles while transitions are taking place. You can also use the `animate()` function to define the `keyframes()` function for multi-step animations. These definitions are placed in the second argument of the `animate()` function." />
      <item value="To make the change less abrupt, we need to define an animation *transition* to specify the changes that occur between one state and another over a period of time. The `transition()` function accepts two arguments: the first argument accepts an expression that defines the direction between two transition states, and the second argument accepts an `animate()` function." />
      <item value="In Angular, you can set multiple styles without any animation. However, without further refinement, the button instantly transforms with no fade, no shrinkage, or other visible indicator that a change is occurring." />
      <item value="Let's see how Angular's `state()` function works with the `style⁣­(⁠)` function to set CSS style attributes. In this code snippet, multiple style attributes are set at the same time for the state. In the `open` state, the button has a height of 200 pixels, an opacity of 1, and a background color of yellow." />
      <item value="In HTML, these attributes are set using ordinary CSS styles such as color and opacity. In Angular, use the `style()` function to specify a set of CSS styles for use with animations. You can collect a set of styles in an animation state, and give the state a name, such as `open` or `closed`." />
      <item value="Prerequisites" />
      <item value="Angular's animation system is built on CSS functionality, which means you can animate any property that the browser considers animatable. This includes positions, sizes, transforms, colors, borders, and more. The W3C maintains a list of animatable properties on its [CSS Transitions](https://www.w3.org/TR/css-transitions-1/) page." />
      <item value="Typically, animations involve multiple style *transformations* over time. An HTML element can move, change color, grow or shrink, fade, or slide off the page. These changes can occur simultaneously or sequentially. You can control the timing of each transformation." />
      <item value="* Good animations intuitively call the user's attention to where it is needed." />
      <item value="* Motion greatly enhances the user experience, so animations give users a chance to detect the application's response to their actions." />
      <item value="* Without animations, web page transitions can seem abrupt and jarring." />
      <item value="Animation provides the illusion of motion: HTML elements change styling over time. Well-designed animations can make your application more fun and easier to use, but they aren't just cosmetic. Animations can improve your app and user experience in a number of ways:" />
      <item value="* Access the `ViewContainerRef` of an element by placing a `Directive` injected * with `ViewContainerRef` on the element, or use a `ViewChild` query." />
      <item value="A getter provides easy access to the aliases in the form array instance compared to repeating the `profileForm.get()` method to get each instance. The form array instance represents an undefined number of controls in an array. It's convenient to access a control through a getter, and this approach is easy to repeat for additional controls." />
      <item value="* Use the `patchValue()` method to replace any properties defined in the object that have changed in the form model." />
      <item value="The built-in browser DOM APIs don't automatically protect you from security vulnerabilities. For example, `document`, the node available through `ElementRef`, and many third-party APIs contain unsafe methods. In the same way, if you interact with other libraries that manipulate the DOM, you likely won't have the same automatic sanitization as with Angular interpolations. Avoid directly interacting with the DOM and instead use Angular templates where possible." />
      <item value="Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure." />
      <item value="&quot;organizations which design systems ... are constrained to produce designs which are copies of the communication structures of these organizations.&quot;" />
      <item value="The Angular CLI outputs the client-side code in the `dist` directory by default, so you modify the `outputPath` for the __build__ target in the `angular.json` to keep the client-side build outputs separate from the server-side code. The client-side build output will be served by the Express server." />
      <item value="A Universal app is distributed in two parts: the server-side code that serves up the initial application, and the client-side code that's loaded in dynamically." />
      <item value="`mat-typography-level-to-styles($config, $level)` - Mixin that takes in a configuration object and a typography level, and outputs a short-hand CSS `font` declaration." />
      <item value="Angular Material includes typography utility mixins and functions that you can use to customize your own components" />
      <item value="Angular Material includes typography utility mixins and functions that you can use to customize your&#10;own components:" />
      <item value="Typography customization is an extension of Angular Material's Sass-based theming. Similar to creating a custom theme, you can create a custom **typography configuration**." />
      <item value="host" />
      <item value="The typography levels are collected into a typography config which is used to generate the CSS." />
      <item value="Smaller body and hint text." />
      <item value="Bolder body text." />
      <item value="Typography is a way of arranging type to make text legible, readable, and appealing when displayed. Angular Material's typography is based on the guidelines from the [Material Design spec][1] and is arranged into typography levels. Each level has a `font-size`, `line-height` and `font-weight`. The available levels are:" />
      <item value="legible" />
      <item value="# Angular Material typography" />
      <item value="This file should contain everything that is not affected by the theme like sizes, transitions..." />
      <item value="When using `@mixin`, the theme file should only contain the definitions that are affected by the passed-in theme." />
      <item value="Now you just have to call the `@mixin` function to apply the theme:" />
      <item value="In order to style your own components with Angular Material's tooling, the component's styles must be defined with Sass." />
      <item value="Once CSS variables (custom properties) are available in all the browsers we support, we will explore how to take advantage of them to make theming even simpler." />
      <item value="ripples" />
      <item value="You can include as many themes as you like in this manner. You can also `@include` the `angular-material-theme` in separate files and then lazily load them based on an end-user interaction (how to lazily load the CSS assets will vary based on your application)." />
      <item value="In particular," />
      <item value="Dashboard" />
      <item value="If you run it will automatically install Angular Material for you and run the install schematic." />
      <item value="schematic" />
      <item value="Since an elevation shadow consists of multiple shadow components of varying opacities, the `$opacity` argument of the mixin is considered a factor by which to scale these initial values rather than an absolute value." />
      <item value="Angular Material's elevation classes and mixins allow you to add separation between elements along the z-axis. All material design elements have resting elevations. In addition, some elements may change their elevation in response to user interaction. The [Material Design spec](https://material.io/design/environment/elevation.html) explains how to best use elevation." />
      <item value="elevation" />
      <item value="Use a deprecated shadow-piercing descendant combinator to force styles to apply to all the child elements. Read more about this deprecated solution in the [Angular documentation](https://angular.io/guide/component-styles#deprecated-deep--and-ng-deep)." />
      <item value="Some Angular Material components, specifically overlay-based ones like MatDialog, MatSnackbar, etc., do not exist as children of your component. Often they are injected elsewhere in the DOM. This is important to keep in mind, since even using high specificity and shadow-piercing selectors will not target elements that are not direct children of your component. Global styles are recommended for targeting such components." />
      <item value="##### Selector specificity" />
      <item value="Is the component a child of your component, or does it exist elsewhere in the DOM?" />
      <item value="2. Are your styles more specific than the defaults?" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="321" />
        <entry key="ENGLISH" value="323" />
        <entry key="ROMANIAN" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
</application>