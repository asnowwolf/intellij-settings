<application>
  <component name="AppStorage">
    <histories>
      <item value="Constructors should do little more than initialize variables.&#10;This rule makes the component safe to construct under test without fear that it will do something dramatic like talk to the server.&#10;That's why you call the `HeroService` from within the `ngOnInit` rather than the constructor." />
      <item value="If you comment out the `@Host()` decorator, Angular walks up the injector ancestor tree until it finds the logger at the `AppComponent` level. The logger logic kicks in and the hero display updates with the &quot;!!!&quot; marker to indicate that the logger was found." />
      <item value="You can limit the scope of an injected service to a *branch* of the application hierarchy by providing that service *at the sub-root component for that branch*. This example shows how to make a different instance of `HeroService` available to `HeroesBaseComponent` by adding it to the `providers` array of the `@Component()` decorator of the sub-component." />
      <item value="When Angular creates `AppComponent`, the DI framework creates an instance of `LoggerService` and starts to create `UserContextService`.&#10;`UserContextService` also needs `LoggerService`, which the framework already has, so the framework can provide the same instance. `UserContextService` also needs `UserService`, which the framework has yet to create. `UserService` has no further dependencies, so the framework can simply use `new` to instantiate the class and provide the instance to the `UserContextService` constructor." />
      <item value="`UserContext` in turn depends on both `LoggerService` and `UserService`, another service that gathers information about a particular user." />
      <item value="`UserContext` in turn depends on both `LoggerService` and&#10;`UserService`, another service that gathers information about a particular user." />
      <item value="* [Building and Serving](guide/build): Learn to define different build and proxy server configurations for your project, such as development, staging, and production." />
      <item value="Add the `&lt;base&gt;` element just after the `&lt;head&gt;` tag. If the `app` folder is the application root, as it is for this application, set the `href` value in **`index.html`** *exactly* as shown here." />
      <item value="Add the `&lt;base&gt;` element just after the `&lt;head&gt;` tag.&#10;If the `app` folder is the application root, as it is for this application, set the `href` value in **`index.html`** *exactly* as shown here." />
      <item value="After the Tutorial and Architecture guide, you'll be ready to continue exploring Angular on your own through the other guides and references in this documentation set, focusing on the features most important for your apps." />
      <item value="* The [Architecture guide](guide/architecture &quot;Architecture guide&quot;) describes key concepts such as modules, components, services, and dependency injection (DI). It provides a foundation for more in-depth guides about specific Angular concepts and features." />
      <item value="The [Tour of Heroes tutorial](tutorial &quot;Tour of Heroes tutorial&quot;) provides additional hands-on learning. It walks you through the steps to build an app that helps a staffing agency manage a group of superhero employees. It has many of the features you'd expect to find in a data-driven application:" />
      <item value="Now that you've seen the essentials of an Angular app and the Angular CLI, continue with these other introductory materials:" />
      <item value="## Final code review" />
      <item value="Angular, the Angular CLI, and Angular apps depend on features and functionality provided by libraries that are available as [npm packages](https://docs.npmjs.com/getting-started/what-is-npm). To download and install npm packages, you must have an npm package manager." />
      <item value="This guide takes less than 30 minutes to complete. At the end of this guide&amp;mdash;as part of final code review&amp;mdash;there is a link to download a copy of the final application code. (If you don't execute the commands in this guide, you can still download the final application code.)" />
      <item value="This guide shows you how to build and run a simple Angular app. You'll use the [Angular CLI tool](cli &quot;CLI command reference&quot;) to accelerate development, while adhering to the [Style Guide](guide/styleguide &quot;Angular style guide&quot;) recommendations that benefit _every_ Angular project." />
      <item value="Welcome to Angular! Angular helps you build modern applications for the web, mobile, or desktop." />
      <item value="It also creates the following workspace and starter project files:" />
      <item value="The Angular CLI installs the necessary Angular `npm` packages and other dependencies. This can take a few minutes." />
      <item value="The `ng new` command prompts you for information about features to include in the initial app project. Accept the defaults by pressing the Enter or Return key." />
      <item value="Ensure that you are not already in an Angular workspace folder. For example, if you have previously created the Getting Started workspace, change to the parent of that folder." />
      <item value="You develop apps in the context of an Angular [workspace](guide/glossary#workspace). A workspace contains the files for one or more [projects](guide/glossary#project). A project is the set of files that comprise an app, a library, or end-to-end (e2e) tests. For this tutorial, you will create a new workspace." />
      <item value="**Note:**: You do not need to complete the entire Getting Started. After you complete the above two sections of Getting Started, your environment is set up. Continue below to create the Tour of Heroes workspace and an initial app project." />
      <item value="  [Prerequisites](guide/quickstart#prerequisites)&#10;" />
      <item value="To set up your development environment, follow these instructions in [Getting Started](guide/quickstart):" />
      <item value="You begin by creating an initial application using the Angular CLI. Throughout this tutorial, youâ€™ll modify and extend that starter application to create the Tour of Heroes app." />
      <item value="Another reason to re-provide a service at another level is to substitute a _ more specialized _ implementation of that service, deeper in the component tree." />
      <item value="Another reason to re-provide a service at another level is to substitute a _more specialized_ implementation of that service, deeper in the component tree." />
      <item value="If you provide `VillainsService` in the root `AppModule` (where you registered the `HeroesService`), that would make the `VillainsService` available everywhere in the application, including the _Hero_ workflows. If you later modified the `VillainsService`, you could break something in a hero component somewhere. Providing the service in the root `AppModule` creates that risk." />
      <item value="For example, the guide sample includes a `VillainsListComponent` that displays a list of villains.&#10;It gets those villains from a `VillainsService`." />
      <item value="If you only register providers with the root injector at the top level (typically the root `AppModule`), the tree of injectors appears to be flat.&#10;All requests bubble up to the root injector, whether you configured it with the `bootstrapModule` method, or registered all providers with `root` in their own services." />
      <item value="See an [example](guide/dependency-injection-in-action#qualify-dependency-lookup) of using `@Host` together with `@Optional`, another parameter decorator that lets you handle the null case if no provider is found." />
      <item value="You can cap the bubbling by adding the `@Host()` parameter decorator on the dependant-service parameter in a component's constructor. The hunt for providers stops at the injector for the host element of the component." />
      <item value="If you have registered a provider for the same DI token at different levels, the first one Angular encounters is the one it uses to provide the dependency. If, for example, a provider is registered locally in the component that needs a service, Angular doesn't look for another provider of the same service." />
      <item value="Components are a special type of directive, and the `providers` property of `@Component()` is inherited from `@Directive()`. Directives can also have dependencies, and you can configure providers in their `@Directive()` metadata. When you configure a provider for a component or directive using the `providers` property, that provider belongs to the injector for the anchor DOM element. Components and directives on the same element share an injector." />
      <item value="The following example is a revised `HeroesComponent` that specifies `HeroService` in its `providers` array. `HeroService` can provide heroes to instances of this component, or to any child component instances." />
      <item value="Here is an example of the case where the component router configuration includes a non-default [location strategy](guide/router#location-strategy) by listing its provider in the `providers` list of the `AppModule`." />
      <item value="You generally don't need to specify `AppModule` with `providedIn`, because the app's `root` injector is the `AppModule` injector. However, if you configure a app-wide provider in the`@NgModule()` metadata for `AppModule`, it overrides one configured for `root` in the `@Injectable()` metadata. You can do this to configure a non-default provider of a service that is shared with multiple apps." />
      <item value="You can configure a provider at the module level using the `providedIn` metadata option for a non-root NgModule, in order to limit the scope of the provider to that module.&#10;This is the equivalent of specifying the non-root module in the `@Injectable()` metadata, except that the service provided this way is not tree-shakable." />
      <item value="This is generally no different from configuring the injector of the NgModule itself, except that the service is tree-shakable if the NgModule doesn't use it. It can be useful for a library that offers a particular service that some components *might* want to inject optionally, and leave it up to the app whether to provide the service." />
      <item value="Providing a service with the app's root injector is a typical case, and the CLI sets up this kind of a provider automatically for you when generating a new service. However, you might not always want to provide your service at the root level. You might, for instance, want users to explicitly opt-in to using the service." />
      <item value="This configuration tells Angular that the app's root injector is responsible for creating an instance of `HeroService` by invoking its constructor, and for making that instance available across the application." />
      <item value="The `@Injectable()` decorator identifies every service class. The `providedIn` metadata option for a service class configures a specific injector (typically `root`) to use the decorated class as a provider of the service. When an injectable class provides its own service to the `root` injector, the service is available anywhere the class is imported." />
      <item value="In our sample app, `HeroComponent` is created when the application starts and is never destroyed, so the `HeroService` instance created for `HeroComponent` lives for the life of the app. If you want to restrict `HeroService` access to `HeroComponent` and its nested `HeroListComponent`, provide `HeroService` at the component level, in `HeroComponent` metadata." />
      <item value="Use the `@NgModule()` `provides` option if a module is [lazy loaded](guide/lazy-loading-ngmodules). The module's own injector is configured with the provider when that module is loaded, and Angular can inject the corresponding services in any class it creates in that module. If you use the `@Injectable()` option `providedIn: MyLazyloadModule`, the provider could be shaken out at compile time, if it is not used anywhere else in the app." />
      <item value="Learn more about dependency resolution through the injector hierarchy: [What you always wanted to know about Angular Dependency Injection tree](https://blog.angularindepth.com/angular-dependency-injection-and-tree-shakeable-tokens-4588a8f70d5d)" />
      <item value="You're likely to inject `UserService` in many places throughout the app and will want to inject the same service instance every time. Providing `UserService` through the `root` injector is a good choice, and is the default that the [Angular CLI](cli) uses when you generate a service for your app." />
      <item value="You can configure providers for different injectors in the injector hierarchy. An internal platform-level injector is shared by all running apps. The `AppModule` injector is the root of an app-wide injector hierarchy, and within an NgModule, directive-level injectors follow the structure of the component hierarchy." />
      <item value="The `ng serve` command builds, watches, and serves the application from local memory, using a local development server. When you have deployed your app to another server, however, you might still want to serve the app so that you can continue to see changes that you make in it. You can do this by adding the `--watch` option to the `ng build` command." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="430" />
        <entry key="ENGLISH" value="433" />
        <entry key="ROMANIAN" value="1" />
        <entry key="ITALIAN" value="1" />
      </map>
    </option>
  </component>
</application>